\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver Network Module}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents an implementation, using literate
programming, of the network code required for secure synchronization
between different instances of a game or interactive software built on
the Weaver game engine. It covers both the message exchange mechanisms
and the cryptographic components responsible for ensuring
confidentiality, integrity, and mutual authentication among the
participating programs.}

\secao{1. Introduction}

\subsecao{1.1. Exported Functions}

The network module of the Weaver game engine defines and exports a set
of functions that can be used externally. We will list these functions
and their signatures here.

First, the initialization and shutdown functions. The initialization
function must be the first one called, before any other function
listed below. The shutdown function must be the last: after invoking
it, no other network function should be called (except the
initialization function to reinitialize this module). The
initialization function must also receive pairs of functions for
memory allocation and deallocation: one pair for temporary allocations
and another for permanent allocations. Adding this support for custom
memory managers is performed by all Weaver modules.

@<Function Declaration (network.h)@>=
void _Winit_network(void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *));
void _Wfinish_network(void);
@

To create a new connection (but not activate it yet), we use:

@<Function Declaration (network.h)@>+=
struct connection *_Wcreate_connection(void);
@

\subsecao{1.2. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{network.h}.

We show below the structure of the file \monoespaco{network.h}:

@(src/network.h@>=
#ifndef __WEAVER_NETWORK
#define __WEAVER_NETWORK
#ifdef __cplusplus
extern "C" {
#endif
#include <stdlib.h> // Standard library
//@<Include General Headers (network.h)@>
//@<General Macros (network.h)@>
//@<Data Structures (network.h)@>
@<Function Declaration (network.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

The code above shows the default boilerplate for defining a header in
our C API. The first two lines and the last one are macros that ensure
the header is not included more than once in a single compilation
unit. Lines 3, 4, 5, and the three lines before the last one make the
header compatible with C++ code. These lines tell the compiler that we
are using C code and, therefore, it can apply optimizations assuming
that no C++-specific features---such as operator overloading---will be
used.

Next, we include a header that allows us to use boolean variables. You
may also notice some parts highlighted in red. One of them is labeled
``Function Declaration (network.h)'', the same title used for most of
the code declared earlier. This means that all previously defined code
blocks with that title will be inserted at this point in the file. The
other red-highlighted parts represent code that we will define in the
following sections.

If you want to understand how the \monoespaco{network.c} file
relates to this header, its structure is as follows:

@(src/network.c@>=
#include "network.h"
#if defined(__EMSCRIPTEN__)
#include <emscripten.h>
#endif
#include <stdbool.h> // We need boolean types
#include <string.h>  // We need 'memset'
#include <unistd.h>  // We need 'close'
@<Local Headers (network.c)@>
//@<Local Macros (network.c)@>
//@<Local Data Structures (network.c)@>
@<Local Variables (network.c)@>
@<Auxiliary Local Functions (network.c)@>
@<API Functions Definition (network.c)@>
@

All the code presented in this document will be placed in one of these
two files. No other files will be created.

\secao{2. Newtwork Module Initialization}

The first part of the code we will introduce consists of the
network-related headers. On Windows, the library used is
``winsock2''. This library must also be linked externally to the
program, but this can be done using a ``pragma'' directive for the
compiler:

@<Local Headers (network.c)@>=
#if defined(_WIN32)
#include <winsock2.h>
#pragma comment(lib,"wsock32.lib")
#endif
@

On Unix-based systems, we only need to include the appropriate
headers. The ability to establish connections is already part of the
standard libraries and does not require linking with external
libraries:

@<Local Headers (network.c)@>+=
#if defined(__unix__)
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#endif
@

If we are running WebAssembly in a web browser, network connections
must be made using the browser's own capabilities, and this does not
require any special headers.

In most environments, no special initialization is required before
using functions to establish network connections. However, there are
exceptions (Windows, for example), and for this reason, it is
important to have a function that handles the initialization of the
network module. This function performs initialization on systems where
it is needed. On other systems, initialization is still important, but
only for storing our allocation and deallocation functions.

@<Local Headers (network.c)@>+=
#include <stdlib.h> // Require: 'malloc', 'free'
@

@<Local Variables (network.c)@>=
// By default, the allocation and deallocation functions are from stdlib.
// But the initialization below may change this:
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@

@<API Functions Definition (network.c)@>=
void _Winit_network(void *(*p_alloc)(size_t), void (*p_free)(void *),
                    void *(*t_alloc)(size_t), void (*t_free)(void *)){
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  temporary_alloc = t_alloc;
  temporary_free = t_free;  
#if defined(_WIN32) // Windows:
  WSADATA WsaData;
  WSAStartup(MAKEWORD(2,2), &WsaData);
#endif
  //@<Weaver Network: Initialization@>
  return;
}
@

Systems that require additional initialization to use the network may
also require a shutdown procedure, which is invoked below:

@<API Functions Definition (network.c)@>+=
void _Wfinish_network(void){
#if defined(_WIN32) // Windows:
  WSACleanup();
#endif
  return;
}
@

\secao{3. Network Primitives}

\subsecao{3.1. Identifying an Address}

Before starting any type of connection, we must be able to know which
address we should connect to. Addresses can be the IPs of other
machines in IPv4 or IPv6. They can also be a domain name.

The rules we will adopt to identify the type of address are based on
RFC 3986:

\alinhaverbatim
<address>         -> <host>
<host>             -> <IPv6 address>
                      <IPv4 address> |
	              <Register Name>
<IPv4 address>    -> <Decimal Octet> "." <Decimal Octet> "." <Decimal Octet>
                      "." <Decimal Octet>
<IPv6 address>    -> Complex rules to be defined. But they alway contain ":".
<Decimal Octet>   -> Number between 0 and 255 (inclusive). With no leading zeroes.
<Register Nmae> -> Any amount of letters, digits and several symols,
                   but without ":", "[" and "]"
\alinhanormal

We therefore need a function that takes an integer and returns an integer representing an address type. The return value will be -1 if the address is not valid, 1 if it is IPv4, 2 if it is IPv6, and 3 if it is a domain name.

The function will work by storing a variable
\monoespaco{may_be_ipv4} which will be initialized as true, but will become false as soon as we find something that indicates what we have cannot be an IPv4. This is because there is ambiguity in the rules for defining a domain name and an IPv4, but as long as something can be interpreted as IPv4, this must be the preferred interpretation.

To identify what type of address we have, we will iterate over each character of the address. As soon as we find a colon (“:”), the address can only be IPv6. We interrupt the entire computation and return. As soon as we find a lowercase or uppercase letter above “f” or “F”, we can assume with absolute certainty that we have a hostname (domain name).

If we reach the end of our loop and identify that the address may be an IPv4, then it will be an IPv4. Otherwise, it will be a domain name (an IPv6 always has a “:”, so we return from our function before the end of the loop if we find such a character).

While our address may still be an IPv4, we count the characters we receive up to the next dot and concatenate them into a buffer. If we read more than 3 characters, it certainly won’t be an IPv4. If the character is not numeric, it won’t be IPv4. If we read 2 or 3 characters that have a leading zero, it also won’t be IPv4. If the characters cannot be converted into a number between 0 and 255, it won’t be IPv4 either.

Here is our code:

@<Auxiliary Local Functions (network.c)@>=
#define ADDRESS_TYPE_INVALID -1
#define ADDRESS_TYPE_IPV4     1
#define ADDRESS_TYPE_IPV6     2
#define ADDRESS_TYPE_DOMAIN   3
int detect_address_type(char *address){
  bool may_be_ipv4 = true;
  char buffer[4], *c;
  int number_of_chars_before_point = 0;
  if(address[0] == '\0')
    return ADDRESS_TYPE_INVALID;
  for(c = address; *c != '\0'; c ++){
    if(*c == ':')
      return ADDRESS_TYPE_IPV6;
    if((*c > 'f' && *c <= 'z') || (*c > 'F' && *c <= 'Z'))
      return ADDRESS_TYPE_DOMAIN;
    if(may_be_ipv4){
      if(*c == '.'){
        int num;
        if(number_of_chars_before_point < 1 ||
	   number_of_chars_before_point > 3){
          may_be_ipv4 = false;
          continue;
        }
	if(number_of_chars_before_point > 1 && buffer[0] == '0'){
          may_be_ipv4 = false;
          continue;
        }
	buffer[number_of_chars_before_point] = '\0';
	num = atoi(buffer);
	if(num > 255){
          may_be_ipv4 = false;
          continue;
        }
	number_of_chars_before_point = 0;
	continue;
      }
      if(*c < '0' || *c > '9'){
        may_be_ipv4 = false;
	continue;
      }
      buffer[number_of_chars_before_point] = *c;
      number_of_chars_before_point ++;
      if(number_of_chars_before_point > 3){
        may_be_ipv4 = false;
	continue;
      }
    }
  }
  if(may_be_ipv4)
    return ADDRESS_TYPE_IPV4;
  else
    return ADDRESS_TYPE_DOMAIN;
}
@

\subsecao{Connecting to an Address}

When we connect to another machine, we need to know its address, its
port, and whether the connection should be made via TCP or UDP. To do
this, we will define a function that takes these three pieces of
information as arguments, creates a socket, and connects to it,
opening a connection with the specified machine.

The function will take the following values as input:

1) address: An address, which is a string containing either an IPv4,
IPv6, or a domain name.

2) port: A string containing a port number written in decimal digits,
or alternatively, the name of a protocol recognized by the operating
system we are running on, in case we want the OS to determine the
correct port.

3) A value that can be SOCK_STREAM (TCP) or SOCK_DGRAM (UDP).

The return value will be an integer representing the identifier of a
socket that has been opened and is connected to the specified address,
or -1 if the connection could not be established.

To implement this, we will rely on the getaddrinfo function, which
will perform most of the work of interpreting the given address and
generating structures that can then be used by the system call
``connect'':

@<Auxiliary Local Functions (network.c)@>=
int connect_socket(char *address, char *port, int type){
  struct addrinfo hints;
  int s, sfd;
  struct addrinfo *result, *rp;
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;    /* Either IPv4 or IPv6 */
  hints.ai_socktype = type;
  s = getaddrinfo(address, port, &hints, &result);
  if(s != 0)
    return -1;
  for (rp = result; rp != NULL; rp = rp->ai_next) {
    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if(sfd == -1)
      continue;
    if(connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
      break; /* Success */
    close(sfd);
  }
  freeaddrinfo(result); /* Deallocating */
  if(rp == NULL)
    return -1;
  return sfd;
}
@


\secao{Mathematical Primitives}

\subsecao{The Finite Field Modulo $2^{255}-19$}

A considerable portion of the cryptographic operations we will perform
take place in a finite field. That is, in a mathematical structure where
we can perform multiplications and additions, but where the set of
elements that can be added and multiplied is finite. In our case, it will
be a set formed by the integers ranging from zero up to $2^{255}-20$.

Addition and multiplication over such integers behave very similarly to
what we are used to when working with ordinary integers. However, after
performing any operation, the final result is obtained by dividing the
value by $2^{255}-19$  and replacing it with the remainder of this
division. In this way, the result of any usual mathematical operation
always remains within our finite interval.

For example, the sum: $(2^{255}-20) + (1) = 0$. In an infinite set of
integers, this sum would yield $2^{255}-20$. But this value is larger
than what we can represent in our finite set. Therefore, it is
replaced by the remainder of its division by $2^{255}-19$, which is
zero.

Each element of our finite field can be represented using vectors of four
unsigned 64-bit integers. This is the representation we will use for the
elements of this finite field.

Thus, the zero element of our group will be:

\alinhaverbatim
{UINT64\_C(0x0), UINT64\_C(0x0), UINT64\_C(0x0), UINT64\_C(0x0)}
\alinhanormal

While the greatest value inn the field will be:

\alinhaverbatim
{UINT64\_C(0x7fffffffffffffff), UINT64\_C(0xffffffffffffffff),
 UINT64\_C(0xffffffffffffffff), UINT64\_C(0xffffffffffffffec)}
\alinhanormal

Since the most significant bit of our entire list will always be zero
for elements of our group, this means we can always add two group
elements and store the result in a vector of four unsigned 64-bit
integers without causing an overflow that we would be unable to
represent in the structure.

We can then add two values using the operation below (which is still
incomplete because it does not yet account for the result becoming
larger than what can be represented in the group):

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_incomplete_add(uint64_t destiny[4], uint64_t sum[4]){
  int i;
  uint64_t initial_value;
  int carry = 0;
  for(i = 3; i >= 0; i --){
    initial_value = destiny[i];
    destiny[i] += sum[i] + carry;
    carry = (destiny[i] < initial_value);
    carry += ((destiny[i] == initial_value) * (sum[i] != 0));
  }
}
@

From now on, we will refer to the group of integers between 0 and
$2^{255}-19$ as $F_{2^{255}-19}$, or f_255_19 when referring to
the group in code, as we did in the function above.

This group has a characteristic that makes it convenient for use in
group operations. When we perform an operation on two of its elements,
we may obtain a value greater than $2^{255}-19$, which means the value
must be normalized back into the group. But thanks to the following
property:

$$
2^{255}\equiv 19 (mod\,\,2^{255}=19)
$$

Thus, any multiple of $2^{255}-19$ can be replaced by a multiple of
19.  In short, if during an addition we obtain a value where the last
bit is set (that is, the bit corresponding to $2^{255}$), we can
simply clear that bit and add 19 to the remaining number. Then we
repeat the process as long as the last bit is still set. After that,
we only need to check whether the resulting value lies within the
bounds of the group. If it does not, there are only 19 invalid values
whose most significant bit is zero. Handling them is simply a matter
of setting the three most significant 64-bit words to zero and
replacing the least significant one with the current value minus
0xffffffffffffffed.

The code that performs this is:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_normalize(uint64_t n[4]){
  int still_big;
  uint64_t nineteen[4];
  nineteen[0] = 0x0;
  nineteen[1] = 0x0;
  nineteen[2] = 0x0;
  nineteen[3] = 0x0;
  nineteen[3] = 19 * ((n[0] & 0x8000000000000000) == 0x8000000000000000);
  n[0] = (n[0] & 0x7fffffffffffffff);
  f_255_19_incomplete_add(n, nineteen);
  still_big = (n[0] == 0x7fffffffffffffff) * (n[1] == ~0x0) * 
              (n[2] == ~0x0) * (n[3] > 0xffffffffffffffec);
  n[0] -= n[0] * still_big;
  n[1] -= n[1] * still_big;
  n[2] -= n[2] * still_big;
  n[3] -= 0xffffffffffffffed * still_big;
}
@

For the sake of completeness, we can also create a second version of the
normalization function. However, instead of normalizing a 256-bit
number, we normalize a 512-bit number so that it becomes a field
element. This will be useful later when we define multiplication, since
our algorithm will produce a non-normalized value with many more bits
after performing a simple multiplication. The second normalization
function is:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_normalize2(uint64_t input[8], uint64_t output[4]){
  int still_big, i;
  uint64_t nineteen[4];
  nineteen[0] = 0x0;
  nineteen[1] = 0x0;
  nineteen[2] = 0x0;
  nineteen[3] = 0x0;
  output[3] = input[7];
  output[2] = input[6];
  output[1] = input[5];
  output[0] = input[4];
  f_255_19_normalize(output);
  for(i = 0; i < 4; i ++){
    int bit;
    for(bit = 0; bit < 8; bit ++){
      int value = ((input[i] >> bit) % 2);
      nineteen[3] = 19 * value;
      f_255_19_incomplete_add(output, nineteen);
      still_big = ((output[0] == 0x7fffffffffffffff) * (output[1] == ~0x0) * 
                   (output[2] == ~0x0) * (output[3] > 0xffffffffffffffec));
      output[0] -= output[0] * still_big;
      output[1] -= output[1] * still_big;
      output[2] -= output[2] * still_big;
      output[3] -= 0xffffffffffffffed * still_big;
    }
  }
}
@

The function above begins by performing normalization while
considering the least significant 256 bits, as before. Then, for the
more significant bits, note that each nonzero bit corresponds to
adding a multiple of $2^{255}$ to the value obtained so far. For each
such bit, we therefore add 19 to the accumulated value and renormalize
it.

Note that the code above does what we previously described, but in a
somewhat more complicated way: it avoids conditionals and ensures that
each iteration runs a fixed number of times. This is necessary in
cryptographic code to guarantee that no information is leaked to an
attacker through timing differences in the execution of an
algorithm. For this reason, we also avoid the logical AND and OR
operators to prevent short-circuit evaluation: cases where the
expression is not fully evaluated because its value becomes evident
after the first operations.

With the incomplete addition function and the normalization function in
hand, we can implement the function that actually adds two elements of
the group, producing a third element:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_add(uint64_t a[4], uint64_t b[4]){ // a = a + b
  f_255_19_incomplete_add(a, b);
  f_255_19_normalize(a);
}
@

To perform subtraction, we only need to compute the additive inverse of
a group element; we do not need a separate subtraction function. To
obtain the additive inverse, we simply take the largest element of the
group, subtract the element from it, and add 1.

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_additive_inverse(uint64_t n[4]){ // n = -n
  uint64_t biggest[4], one[4], initial;
  int i, carry = 0;
  biggest[0] = 0x7fffffffffffffff;
  biggest[1] = 0xffffffffffffffff;
  biggest[2] = 0xffffffffffffffff;
  biggest[3] = 0xffffffffffffffec;
  one[0] = one[1] = one[2] = 0;
  one[3] = 1;
  for(i = 3; i >= 0 ; i --){
    initial = n[i];
    n[i] = biggest[i] - n[i] - carry;
    carry = (n[i] > biggest[i]);
    carry = (n[i] == biggest[i]) * (initial != 0);
  }
  f_255_19_add(n, one);
}
@


\fim