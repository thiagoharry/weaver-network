\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver Network Module}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents an implementation, using literate
programming, of the network code required for secure synchronization
between different instances of a game or interactive software built on
the Weaver game engine. It covers both the message exchange mechanisms
and the cryptographic components responsible for ensuring
confidentiality, integrity, and mutual authentication among the
participating programs.}

\secao{1. Introduction}

\subsecao{1.1. Exported Functions}

The network module of the Weaver game engine defines and exports a set
of functions that can be used externally. We will list these functions
and their signatures here.

First, the initialization and shutdown functions. The initialization
function must be the first one called, before any other function
listed below. The shutdown function must be the last: after invoking
it, no other network function should be called (except the
initialization function to reinitialize this module). The
initialization function must also receive pairs of functions for
memory allocation and deallocation: one pair for temporary allocations
and another for permanent allocations. Adding this support for custom
memory managers is performed by all Weaver modules. Additionally, the
function receives another function that corresponds to a
cryptographically secure random number generator. When invoked, this
function must generate 64 random bits.

@<Function Declaration (network.h)@>=
void _Winit_network(void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *),
                    uint64_t (*rand)(void));
void _Wfinish_network(void);
@

To create a new connection (but not activate it yet), we use:

@<Function Declaration (network.h)@>+=
struct connection *_Wcreate_connection(void);
@

\subsecao{1.2. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{network.h}.

We show below the structure of the file \monoespaco{network.h}:

@(src/network.h@>=
#ifndef __WEAVER_NETWORK
#define __WEAVER_NETWORK
#ifdef __cplusplus
extern "C" {
#endif
#include <stdlib.h> // Standard library
//@<Include General Headers (network.h)@>
//@<General Macros (network.h)@>
//@<Data Structures (network.h)@>
@<Function Declaration (network.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

The code above shows the default boilerplate for defining a header in
our C API. The first two lines and the last one are macros that ensure
the header is not included more than once in a single compilation
unit. Lines 3, 4, 5, and the three lines before the last one make the
header compatible with C++ code. These lines tell the compiler that we
are using C code and, therefore, it can apply optimizations assuming
that no C++-specific features---such as operator overloading---will be
used.

Next, we include a header that allows us to use boolean variables. You
may also notice some parts highlighted in red. One of them is labeled
``Function Declaration (network.h)'', the same title used for most of
the code declared earlier. This means that all previously defined code
blocks with that title will be inserted at this point in the file. The
other red-highlighted parts represent code that we will define in the
following sections.

If you want to understand how the \monoespaco{network.c} file
relates to this header, its structure is as follows:

@(src/network.c@>=
#include "network.h"
#if defined(__EMSCRIPTEN__)
#include <emscripten.h>
#endif
#include <stdbool.h> // We need boolean types
#include <string.h>  // We need 'memset'
#include <unistd.h>  // We need 'close'
@<Local Headers (network.c)@>
//@<Local Macros (network.c)@>
//@<Local Data Structures (network.c)@>
@<Local Variables (network.c)@>
@<Auxiliary Local Functions (network.c)@>
@<API Functions Definition (network.c)@>
@

All the code presented in this document will be placed in one of these
two files. No other files will be created.

\secao{2. Newtwork Module Initialization}

The first part of the code we will introduce consists of the
network-related headers. On Windows, the library used is
``winsock2''. This library must also be linked externally to the
program, but this can be done using a ``pragma'' directive for the
compiler:

@<Local Headers (network.c)@>=
#if defined(_WIN32)
#include <winsock2.h>
#pragma comment(lib,"wsock32.lib")
#endif
@

On Unix-based systems, we only need to include the appropriate
headers. The ability to establish connections is already part of the
standard libraries and does not require linking with external
libraries:

@<Local Headers (network.c)@>+=
#if defined(__unix__)
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#endif
@

If we are running WebAssembly in a web browser, network connections
must be made using the browser's own capabilities, and this does not
require any special headers.

In most environments, no special initialization is required before
using functions to establish network connections. However, there are
exceptions (Windows, for example), and for this reason, it is
important to have a function that handles the initialization of the
network module. This function performs initialization on systems where
it is needed. On other systems, initialization is still important, but
only for storing our allocation and deallocation functions.

@<Local Headers (network.c)@>+=
#include <stdlib.h> // Require: 'malloc', 'free'
@

@<Local Variables (network.c)@>=
// By default, the allocation and deallocation functions are from stdlib.
// But the initialization below may change this:
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
static uint64_t (*random_function)(void) = NULL;
@

@<API Functions Definition (network.c)@>=
void _Winit_network(void *(*p_alloc)(size_t), void (*p_free)(void *),
                    void *(*t_alloc)(size_t), void (*t_free)(void *),
                    uint64_t (*rand)(void)){
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  temporary_alloc = t_alloc;
  temporary_free = t_free;
  random_function = rand;
#if defined(_WIN32) // Windows:
  WSADATA WsaData;
  WSAStartup(MAKEWORD(2,2), &WsaData);
#endif
  //@<Weaver Network: Initialization@>
  return;
}
@

Systems that require additional initialization to use the network may
also require a shutdown procedure, which is invoked below:

@<API Functions Definition (network.c)@>+=
void _Wfinish_network(void){
#if defined(_WIN32) // Windows:
  WSACleanup();
#endif
  return;
}
@

\secao{3. Network Primitives}

\subsecao{3.1. Identifying an Address}

Before starting any type of connection, we must be able to know which
address we should connect to. Addresses can be the IPs of other
machines in IPv4 or IPv6. They can also be a domain name.

The rules we will adopt to identify the type of address are based on
RFC 3986:

\alinhaverbatim
<address>         -> <host>
<host>             -> <IPv6 address>
                      <IPv4 address> |
	              <Register Name>
<IPv4 address>    -> <Decimal Octet> "." <Decimal Octet> "." <Decimal Octet>
                      "." <Decimal Octet>
<IPv6 address>    -> Complex rules to be defined. But they alway contain ":".
<Decimal Octet>   -> Number between 0 and 255 (inclusive). With no leading zeroes.
<Register Nmae> -> Any amount of letters, digits and several symols,
                   but without ":", "[" and "]"
\alinhanormal

We therefore need a function that takes an integer and returns an integer representing an address type. The return value will be -1 if the address is not valid, 1 if it is IPv4, 2 if it is IPv6, and 3 if it is a domain name.

The function will work by storing a variable
\monoespaco{may_be_ipv4} which will be initialized as true, but will become false as soon as we find something that indicates what we have cannot be an IPv4. This is because there is ambiguity in the rules for defining a domain name and an IPv4, but as long as something can be interpreted as IPv4, this must be the preferred interpretation.

To identify what type of address we have, we will iterate over each character of the address. As soon as we find a colon (“:”), the address can only be IPv6. We interrupt the entire computation and return. As soon as we find a lowercase or uppercase letter above “f” or “F”, we can assume with absolute certainty that we have a hostname (domain name).

If we reach the end of our loop and identify that the address may be an IPv4, then it will be an IPv4. Otherwise, it will be a domain name (an IPv6 always has a “:”, so we return from our function before the end of the loop if we find such a character).

While our address may still be an IPv4, we count the characters we receive up to the next dot and concatenate them into a buffer. If we read more than 3 characters, it certainly won’t be an IPv4. If the character is not numeric, it won’t be IPv4. If we read 2 or 3 characters that have a leading zero, it also won’t be IPv4. If the characters cannot be converted into a number between 0 and 255, it won’t be IPv4 either.

Here is our code:

@<Auxiliary Local Functions (network.c)@>=
#define ADDRESS_TYPE_INVALID -1
#define ADDRESS_TYPE_IPV4     1
#define ADDRESS_TYPE_IPV6     2
#define ADDRESS_TYPE_DOMAIN   3
int detect_address_type(char *address){
  bool may_be_ipv4 = true;
  char buffer[4], *c;
  int number_of_chars_before_point = 0;
  if(address[0] == '\0')
    return ADDRESS_TYPE_INVALID;
  for(c = address; *c != '\0'; c ++){
    if(*c == ':')
      return ADDRESS_TYPE_IPV6;
    if((*c > 'f' && *c <= 'z') || (*c > 'F' && *c <= 'Z'))
      return ADDRESS_TYPE_DOMAIN;
    if(may_be_ipv4){
      if(*c == '.'){
        int num;
        if(number_of_chars_before_point < 1 ||
	   number_of_chars_before_point > 3){
          may_be_ipv4 = false;
          continue;
        }
	if(number_of_chars_before_point > 1 && buffer[0] == '0'){
          may_be_ipv4 = false;
          continue;
        }
	buffer[number_of_chars_before_point] = '\0';
	num = atoi(buffer);
	if(num > 255){
          may_be_ipv4 = false;
          continue;
        }
	number_of_chars_before_point = 0;
	continue;
      }
      if(*c < '0' || *c > '9'){
        may_be_ipv4 = false;
	continue;
      }
      buffer[number_of_chars_before_point] = *c;
      number_of_chars_before_point ++;
      if(number_of_chars_before_point > 3){
        may_be_ipv4 = false;
	continue;
      }
    }
  }
  if(may_be_ipv4)
    return ADDRESS_TYPE_IPV4;
  else
    return ADDRESS_TYPE_DOMAIN;
}
@

\subsecao{Connecting to an Address}

When we connect to another machine, we need to know its address, its
port, and whether the connection should be made via TCP or UDP. To do
this, we will define a function that takes these three pieces of
information as arguments, creates a socket, and connects to it,
opening a connection with the specified machine.

The function will take the following values as input:

1) address: An address, which is a string containing either an IPv4,
IPv6, or a domain name.

2) port: A string containing a port number written in decimal digits,
or alternatively, the name of a protocol recognized by the operating
system we are running on, in case we want the OS to determine the
correct port.

3) A value that can be SOCK_STREAM (TCP) or SOCK_DGRAM (UDP).

The return value will be an integer representing the identifier of a
socket that has been opened and is connected to the specified address,
or -1 if the connection could not be established.

To implement this, we will rely on the getaddrinfo function, which
will perform most of the work of interpreting the given address and
generating structures that can then be used by the system call
``connect'':

@<Auxiliary Local Functions (network.c)@>=
int connect_socket(char *address, char *port, int type){
  struct addrinfo hints;
  int s, sfd;
  struct addrinfo *result, *rp;
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;    /* Either IPv4 or IPv6 */
  hints.ai_socktype = type;
  s = getaddrinfo(address, port, &hints, &result);
  if(s != 0)
    return -1;
  for (rp = result; rp != NULL; rp = rp->ai_next) {
    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if(sfd == -1)
      continue;
    if(connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
      break; /* Success */
    close(sfd);
  }
  freeaddrinfo(result); /* Deallocating */
  if(rp == NULL)
    return -1;
  return sfd;
}
@


\secao{Mathematical Primitives}

\subsecao{The Finite Field Modulo $2^{255}-19$}

A considerable portion of the cryptographic operations we will perform
take place in a finite field. That is, in a mathematical structure where
we can perform multiplications and additions, but where the set of
elements that can be added and multiplied is finite. In our case, it will
be a set formed by the integers ranging from zero up to $2^{255}-20$.

Addition and multiplication over such integers behave very similarly to
what we are used to when working with ordinary integers. However, after
performing any operation, the final result is obtained by dividing the
value by $2^{255}-19$  and replacing it with the remainder of this
division. In this way, the result of any usual mathematical operation
always remains within our finite interval.

For example, the sum: $(2^{255}-20) + (1) = 0$. In an infinite set of
integers, this sum would yield $2^{255}-20$. But this value is larger
than what we can represent in our finite set. Therefore, it is
replaced by the remainder of its division by $2^{255}-19$, which is
zero.

Each element of our finite field can be represented using vectors of four
unsigned 64-bit integers. This is the representation we will use for the
elements of this finite field.

Thus, the zero element of our group will be:

\alinhaverbatim
{UINT64\_C(0x0), UINT64\_C(0x0), UINT64\_C(0x0), UINT64\_C(0x0)}
\alinhanormal

While the greatest value inn the field will be:

\alinhaverbatim
{UINT64\_C(0x7fffffffffffffff), UINT64\_C(0xffffffffffffffff),
 UINT64\_C(0xffffffffffffffff), UINT64\_C(0xffffffffffffffec)}
\alinhanormal

Since the most significant bit of our entire list will always be zero
for elements of our group, this means we can always add two group
elements and store the result in a vector of four unsigned 64-bit
integers without causing an overflow that we would be unable to
represent in the structure.

We can then add two values using the operation below (which is still
incomplete because it does not yet account for the result becoming
larger than what can be represented in the group):

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_incomplete_add(uint64_t destiny[4], uint64_t sum[4], int size){
  int i;
  uint64_t initial_value;
  int carry = 0;
  for(i = size - 1; i >= 0; i --){
    initial_value = destiny[i];
    destiny[i] += sum[i] + carry;
    carry = (destiny[i] < initial_value);
    carry += ((destiny[i] == initial_value) * (sum[i] != 0));
  }
}
@

From now on, we will refer to the group of integers between 0 and
$2^{255}-19$ as $F_{2^{255}-19}$, or f_255_19 when referring to
the group in code, as we did in the function above.

This group has a characteristic that makes it convenient for use in
group operations. When we perform an operation on two of its elements,
we may obtain a value greater than $2^{255}-19$, which means the value
must be normalized back into the group. But thanks to the following
property:

$$
2^{255}\equiv 19 (mod\,\,2^{255}=19)
$$

Thus, any multiple of $2^{255}-19$ can be replaced by a multiple of
19.  In short, if during an addition we obtain a value where the last
bit is set (that is, the bit corresponding to $2^{255}$), we can
simply clear that bit and add 19 to the remaining number. Then we
repeat the process as long as the last bit is still set. After that,
we only need to check whether the resulting value lies within the
bounds of the group. If it does not, there are only 19 invalid values
whose most significant bit is zero. Handling them is simply a matter
of setting the three most significant 64-bit words to zero and
replacing the least significant one with the current value minus
0xffffffffffffffed.

The code that performs this is:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_normalize(uint64_t n[4]){
  int still_big;
  uint64_t nineteen[4];
  nineteen[0] = 0x0;
  nineteen[1] = 0x0;
  nineteen[2] = 0x0;
  nineteen[3] = 0x0;
  nineteen[3] = 19 * ((n[0] & 0x8000000000000000) == 0x8000000000000000);
  n[0] = (n[0] & 0x7fffffffffffffff);
  f_255_19_incomplete_add(n, nineteen, 4);
  still_big = (n[0] == 0x7fffffffffffffff) * (n[1] == ~0x0) * 
              (n[2] == ~0x0) * (n[3] > 0xffffffffffffffec);
  n[0] -= n[0] * still_big;
  n[1] -= n[1] * still_big;
  n[2] -= n[2] * still_big;
  n[3] -= 0xffffffffffffffed * still_big;
}
@

Note that the code above does what we previously described, but in a
somewhat more complicated way: it avoids conditionals and ensures that
each iteration runs a fixed number of times. This is necessary in
cryptographic code to guarantee that no information is leaked to an
attacker through timing differences in the execution of an
algorithm. For this reason, we also avoid the logical AND and OR
operators to prevent short-circuit evaluation: cases where the
expression is not fully evaluated because its value becomes evident
after the first operations.

With the incomplete addition function and the normalization function in
hand, we can implement the function that actually adds two elements of
the group, producing a third element:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_add(uint64_t a[4], uint64_t b[4]){ // a = a + b
  f_255_19_incomplete_add(a, b, 4);
  f_255_19_normalize(a);
}
@

To perform subtraction, we only need to compute the additive inverse of
a group element; we do not need a separate subtraction function. To
obtain the additive inverse, we simply take the largest element of the
group, subtract the element from it, and add 1.

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_additive_inverse(uint64_t n[4]){ // n = -n
  uint64_t biggest[4], one[4], initial;
  int i, carry = 0;
  biggest[0] = 0x7fffffffffffffff;
  biggest[1] = 0xffffffffffffffff;
  biggest[2] = 0xffffffffffffffff;
  biggest[3] = 0xffffffffffffffec;
  one[0] = one[1] = one[2] = 0;
  one[3] = 1;
  for(i = 3; i >= 0 ; i --){
    initial = n[i];
    n[i] = biggest[i] - n[i] - carry;
    carry = (n[i] > biggest[i]);
    carry = (n[i] == biggest[i]) * (initial != 0);
  }
  f_255_19_add(n, one);
}
@

Before moving on to multiplication, let us first prepare by creating
another normalization function. Earlier, we created a function that
takes a 256-bit number and transforms it into its version modulo
$2^{255}-19$, and such a transformation is necessary to correctly
compute addition in our finite field. For multiplication, we will also
need a normalization function that does the same for 510-bit numbers.

To normalize such numbers, we will once again rely on the property that
$2^{255}$ is equal to 19 modulo $2^{255}-19$. Note that a 512-bit
number is represented by the sequence:

$$ (b_{509}, \ldots b_{256}, b_{255}, b_{254},
\ldots, b_0) $$

Which can be written as:

$$(b_{509}, \ldots, b_{255})\times19 + (b_{254}, \ldots, b_0) $$

Now we can use this to write the normalization function:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_normalize2(uint64_t src[8], uint64_t dst[4]){
  // Copying bits b_0 to b_{254}:
  dst[3] = src[7];
  dst[2] = src[6];
  dst[1] = src[5];
  dst[0] = src[4] & 0x7fffffffffffffff;
  // Dealing with bits from b_{255} to b_{509}:
  {
    int i;
    uint64_t aux[4], aux_copy[4];
    aux[3] = (src[4] >> 63); //b_{255}
    aux[3] += (src[3] << 1); // Bits b_{256} to b_{318}
    aux[2] = (src[3] >> 63); // b_{319}
    aux[2] += (src[2] << 1); // Bits b_{320} to b_{382}
    aux[1] = (src[2] >> 63); // b_{383}
    aux[1] += (src[1] << 1); // Bits b_{384} to b_{446}
    aux[0] = (src[1] >> 63); // b_{447}
    aux[0] += ((src[0] << 2) >> 1); // b_{448} to b_{509}
    memcpy(aux_copy, aux, sizeof(uint64_t) * 4);
    for(i = 0; i < 4; i ++){ // Multiply aux by 16
      f_255_19_add(aux, aux);
    }
    for(i = 0; i < 3; i ++){ // Compute aux * 19
      f_255_19_add(aux, aux_copy);
    }
    f_255_19_add(dst, aux); // Add to result
  }
}
@

Now let us move on to multiplication. First, we write an algorithm that
multiplies two 256-bit numbers, producing a 512-bit result. Later, we
will normalize the result so that the value lies within our field:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_incomplete_multiply(uint64_t a[4], uint64_t b[4], uint64_t r[8]){
  bool little_endian = true; // TODO: Set in initialization
  uint64_t aux[8];
  uint32_t a32[8], b32[8], aux32[16], carry;
  int i, j;
  memset(r, 0, sizeof(uint64_t) * 8);
  // Convert 'a' and 'b' to uint32_t array:
  memcpy(a32, a, sizeof(uint64_t) * 4);
  memcpy(b32, b, sizeof(uint64_t) * 4);
  if(little_endian){
    for(i = 0; i < 8; i += 2){
      uint32_t tmp = a32[i];
      a32[i] = a32[i + 1];
      a32[i + 1] = tmp;
      tmp = b32[i];
      b32[i] = b32[i + 1];
      b32[i + 1] = tmp;
    }
  }
  for(i = 7; i >= 0; i --){ // Multiplication algorithm
    memset(aux32, 0, sizeof(uint32_t) * 16);
    carry = 0;
    for(j = 7; j >= 0; j --){
      uint64_t result = ((uint64_t) a32[j]) * ((uint64_t) b32[i]) + carry;
      carry = (uint32_t) (result / 0x100000000);
      aux32[1 + i + j ] = result % 0x100000000;
    }
    aux32[1 + i + j] = carry;
    if(little_endian){ // Convert intermediary result to uint64_t array
      for(j = 0; j < 16; j += 2){
        uint32_t tmp = aux32[j];
	aux32[j] = aux32[j + 1];
	aux32[j + 1] = tmp;
      }
    }
    memcpy(aux, aux32, sizeof(uint64_t) * 8);
    f_255_19_incomplete_add(r, aux, 8); // Add to result
  }
}
@

And once we have an algorithm for multiplying 256-bit numbers that
produces a 512-bit result, we can use our normalization function to
complete the multiplication function in our finite field:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_multiply(uint64_t a[4], uint64_t b[4]){ // a = a * b
  uint64_t aux[8];
  f_255_19_incomplete_multiply(a, b, aux);
  f_255_19_normalize2(aux, a);
}
@

The next operation will be to compute the multiplicative inverse. That
is, given the number $n$, determine the value of $n^{-1}$ such that:

$$
n\cdot n^{-1} = 1 \pmod{2^{255}-19}
$$

The safest way to compute this in constant time is by calculating
$n^{2^{255}-21}$. Since the order of this group is $2^{255}-20$, it
follows that modulo $2^{255}-19}$ we have $n^{-1} = n^{2^{255}-21}$.

A well-known way to perform such an exponentiation is to compute
successive values of the form $n^{2^i - 1}$, always trying, whenever
possible, to approach the desired value through successive
multiplications of a number by itself (i.e., squaring), and
multiplying by previously computed terms to reach the final value. One
way to do this using only 267 multiplications can be seen in the
implementation below:

@<Auxiliary Local Functions (network.c)@>+=
void f_255_19_multiplicative_inverse(uint64_t g[4]){ // g = 1/g
  int i;
  uint64_t t0[4], t1[4], t2[4], t3[4], t4[4], t5[4], t6[4], t7[4], z[4], g2[4];
  memcpy(t0, g, sizeof(uint64_t) * 4);
  f_255_19_multiply(t0, t0);
  memcpy(g2, t0, sizeof(uint64_t) * 4); //g2 = g^2
  f_255_19_multiply(t0, g); // t0 = g^(2^2 - 1) = g^3
  memcpy(z, t0, sizeof(uint64_t) * 4);
  f_255_19_multiply(z, z);
  f_255_19_multiply(z, g); // z = g^7
  memcpy(t1, z, sizeof(uint64_t) * 4);
  for(i = 0; i < 2; i ++)
    f_255_19_multiply(t1, t1);
  f_255_19_multiply(t1, t0); // t1 = g^(2^5 - 1) = g^31
  f_255_19_multiply(z, g2); // z = g^9
  f_255_19_multiply(z, g2); // z = g^11
  memcpy(t2, t1, sizeof(uint64_t) * 4);
  for(i = 0; i < 5; i ++)
    f_255_19_multiply(t2, t2);
  f_255_19_multiply(t2, t1); // t2 = g^(2^10 - 1) = g^1023
  memcpy(t3, t2, sizeof(uint64_t) * 4);
  for(i = 0; i < 10; i ++)
    f_255_19_multiply(t3, t3);
  f_255_19_multiply(t3, t2); // t3 = g^(2^20 -1)
  memcpy(t4, t3, sizeof(uint64_t) * 4);
  for(i = 0; i < 20; i ++)
    f_255_19_multiply(t4, t4);
  f_255_19_multiply(t4, t3); // t4 = g^(2^40 -1)
  for(i = 0; i < 10; i ++)
    f_255_19_multiply(t4, t4);
  f_255_19_multiply(t4, t2); // t4 = g^(2^50 -1)
  memcpy(t5, t4, sizeof(uint64_t) * 4);
  for(i = 0; i < 50; i ++)
    f_255_19_multiply(t5, t5);
  f_255_19_multiply(t5, t4); // t5 = g^(2^100 -1)
  memcpy(t6, t5, sizeof(uint64_t) * 4);
  for(i = 0; i < 100; i ++)
    f_255_19_multiply(t6, t6);
  f_255_19_multiply(t6, t5); // t6 = g^(2^200 -1)
  memcpy(t7, t6, sizeof(uint64_t) * 4);
  for(i = 0; i < 50; i ++)
    f_255_19_multiply(t7, t7);
  f_255_19_multiply(t7, t4); // t7 = g^(2^250 -1)
  memcpy(g, t7, sizeof(uint64_t) * 4);
  for(i = 0; i < 5; i ++)
    f_255_19_multiply(g, g);
  f_255_19_multiply(g, z); //  g = g^(2^255 -21)
}
@

There are other methods. For example, in [BERNSTEIN, 2019] there is an
algorithm that also runs in constant time and is a little faster, but
much more complex. However, for our multiplicative group, we will
choose to use the simpler method.

\subsecao{The Elliptic Curve ``Curve25519''}

Given the finite field presented in the previous section, we can
construct an elliptic curve defined by $y^2 = x^3 + 486662x^2 +
x$. The values of the pairs $(x,y)$ are not real numbers, but elements
of the finite field presented.

With the help of this curve, we can define a mathematical group formed
by the points on the curve together with an additional point called
the ``point at infinity.'' The addition operation in the group (A+B)
is defined as being equal to a third point (C) on the curve that is
intersected by the line passing through A and B. The point at infinity
is defined as the identity element of this addition. The additive
inverse of a point on the curve $(a,b)$ is equal to $(a,-b)$ (since
the curve is symmetric with respect to the $x$-axis). And the sum of a
point with itself is equal to the second point on the curve
intersected by the tangent line passing through that same point.

Although the operations of this group are defined geometrically, and
can be visualized geometrically if we define this curve on the
Cartesian plane, in practice we will use it not over the real plane,
but over the plane of the finite field of integers modulo
$2^{255}-19$. Therefore, the transformations performed, even though
they follow the same logic, cannot be visualized graphically.

Technically, to represent a point on the curve, we need two values:
the $x$ coordinate and the $y$ coordinate. However, the curve we will
use is a special type of curve called a ``Montgomery curve.''  It is
any curve of the form $By^2 = x^3 + Ax^2 + x$ such that $B(A^2 - 4)
\neq 0$. In this type of curve, we can achieve better performance and
avoid having to store the $y$ value of each point by performing all
geometric operations in a projection that does not distinguish between
$A+B$, $A-B$, and $B-A$ when carrying out the group operations.

Using this trick, each point can be stored and generated as being
formed only by an $x$ value, ignoring the $y$ coordinate. However, the
algorithms represent them as two values: $(x:z)$. The value $z$ is
always 0 for the point at infinity and starts as 1 for other values.
In a sense, it can be viewed as a fractional representation of our
point, with the value of $z$ acting as a denominator that accumulates
values and is ``reduced'' and removed only once at the end, as a
way to compute the multiplicative inverse (the most computationally
expensive operation in the finite field) only a single time.

Using formulas and this method, we can compute the doubling of a point
on the curve $P+P$ (where $P = (x:z)$) using the function below:

@<Auxiliary Local Functions (network.c)@>+=
void curve25519_double(uint64_t x[4], uint64_t z[4]){ // P = P+P
  uint64_t a[4], b[4], e[4], constant[4];
  constant[0] = constant[1] = constant[2] = 0x0;
  constant[3] = 121666;
  memcpy(a, x, sizeof(uint64_t) * 4);
  f_255_19_add(a, z);
  f_255_19_multiply(a, a);
  memcpy(b, z, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(b);
  f_255_19_add(b, x);
  f_255_19_multiply(b, b);
  memcpy(e, b, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(e);
  f_255_19_add(e, a);
  memcpy(x, a, sizeof(uint64_t) * 4);
  f_255_19_multiply(x, b);
  z[0] = z[1] = z[2] = 0x0; z[3] = 121666;
  f_255_19_multiply(z, e);
  f_255_19_add(z, b);
  f_255_19_multiply(z, e);
}
@

To compute the actual value of the $x$ coordinate of the result, it is
necessary to compute $x \cdot z^{-1}$. However, this final operation
should be postponed as much as possible and performed only at the end
of the operations involving the points on the curve. Therefore, the
function above does not perform it.

On the other hand, to compute the sum of two points $P=(x_1: z_1)$ and
$Q=(x_2: z_2)$, this is impossible to do without taking the
$y$-coordinates of the points into account, except in one special
case: if we want to compute $P+Q$, but we know the $x$-coordinate of
$P-Q$, then we can use this knowledge to add the points without
consulting $y$ (using the so-called differential addition).

To add two points in this way, we use the function below, which takes
as its first two parameters the operands $P = (x_1: z_1)$ and $Q=(x_2:
z_2)$ of the sum (the first operand will be overwritten with the
result), and as its third parameter the point corresponding to $P-Q$.

The function below only produces the correct result for $P \neq Q$.

@<Auxiliary Local Functions (network.c)@>+=
void curve25519_add(uint64_t x1[4], uint64_t z1[4],
                    uint64_t x2[4], uint64_t z2[4],
		    uint64_t xb[4], uint64_t zb[4]){ // P = P+Q
  uint64_t a[4], b[4], c[4], d[4], x[4], z[4];
  memcpy(a, x1, sizeof(uint64_t) * 4);
  f_255_19_add(a, z1); // a = x1+z1
  memcpy(b, z1, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(b);
  f_255_19_add(b, x1); // b = x1-z1
  memcpy(c, x2, sizeof(uint64_t) * 4);
  f_255_19_add(c, z2); // c = x2+z2
  memcpy(d, z2, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(d);
  f_255_19_add(d, x2); // d = x2-z2
  f_255_19_multiply(d, a); // d = d*a = (x2-z2)(x1+z1)
  f_255_19_multiply(c, b); // c = c*b = (x2+z2)(x1-z1)
  memcpy(x, d, sizeof(uint64_t) * 4);
  f_255_19_add(x, c);
  f_255_19_multiply(x, x);
  f_255_19_multiply(x, zb); //x = zb*(d*a+c*b)^2
  memcpy(z, c, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(z);
  f_255_19_add(z, d);
  f_255_19_multiply(z, z);
  f_255_19_multiply(z, xb); //z = xb*(d*a-c*b)^2
  memcpy(x1, x, sizeof(uint64_t) * 4);
  memcpy(z1, z, sizeof(uint64_t) * 4);
}
@

Being able to compute the doubling of a point on the curve and to add
two points in this context, the next step is to implement scalar
multiplication. Given an integer, $k$, and a point on the curve $P$,
the value of $k \cdot P$ is obtained by successively adding the point
$P$ a total of $k$ times. This could be implemented with a simple
loop, but that would be a terrible idea. Such an implementation would
take longer to compute larger values of $k$ than smaller ones, and
this would allow others to determine the value of $k$ through timing
measurements. To use such code in cryptography, information about this
value must not leak in any way.

RFC 7748, in its Section 5, provides a description of an algorithm
that always runs in constant time and does not leak information about
the value of $k$. The algorithms described there are implemented
below:

@<Auxiliary Local Functions (network.c)@>+=
void cswap(int swap, uint64_t x2[4], uint64_t z2[4],
                     uint64_t x3[4], uint64_t z3[4]){
  uint64_t dummy[4];
  uint64_t mask = ((uint64_t) -swap);
  dummy[0] = (x2[0] ^ x3[0]) & mask;
  dummy[1] = (x2[1] ^ x3[1]) & mask;
  dummy[2] = (x2[2] ^ x3[2]) & mask;
  dummy[3] = (x2[3] ^ x3[3]) & mask;
  x2[0] ^= dummy[0]; x2[1] ^= dummy[1];
  x2[2] ^= dummy[2]; x2[3] ^= dummy[3];
  x3[0] ^= dummy[0]; x3[1] ^= dummy[1];
  x3[2] ^= dummy[2]; x3[3] ^= dummy[3];
  dummy[0] = (z2[0] ^ z3[0]) & mask;
  dummy[1] = (z2[1] ^ z3[1]) & mask;
  dummy[2] = (z2[2] ^ z3[2]) & mask;
  dummy[3] = (z2[3] ^ z3[3]) & mask;
  z2[0] ^= dummy[0]; z2[1] ^= dummy[1];
  z2[2] ^= dummy[2]; z2[3] ^= dummy[3];
  z3[0] ^= dummy[0]; z3[1] ^= dummy[1];
  z3[2] ^= dummy[2]; z3[3] ^= dummy[3];  
}
void curve25519_mult(uint64_t x[4], uint64_t z[4], uint64_t scalar[4]){
  int i, swap;
  uint64_t one[4], zero[4];
  uint64_t x2[4], z2[4], x3[4], z3[4];
  zero[0] = zero[1] = zero[2] = zero[3] = 0x0;
  one[0] = one[1] = one[2] = 0x0; one[3] = 0x1;
  memcpy(x2, one, sizeof(uint64_t) * 4);
  memcpy(z2, zero, sizeof(uint64_t) * 4); // X2 = 0
  memcpy(x3, x, sizeof(uint64_t) * 4);
  memcpy(z3, z, sizeof(uint64_t) * 4); // X3 = X
  swap = 0;
  for(i = 254; i >= 0; i --){
    uint64_t a[4], b[4], aa[4], bb[4], e[4], c[4], d[4], da[4], cb[4];
    int bit = (((scalar[3 - (i / 64)]) >> (i % 64)) & 0x1);
    swap ^= bit;
    cswap(swap, x2, z2, x3, z3);
    swap = bit;
    memcpy(a, x2, sizeof(uint64_t) * 4);
    f_255_19_add(a, z2); // A = X2 + Z2
    memcpy(aa, a, sizeof(uint64_t) * 4);
    f_255_19_multiply(aa, aa); // AA = A*A
    memcpy(b, z2, sizeof(uint64_t) * 4);
    f_255_19_additive_inverse(b);
    f_255_19_add(b, x2); // B = X2-Z2
    memcpy(bb, b, sizeof(uint64_t) * 4);
    f_255_19_multiply(bb, bb); // BB = B*B
    memcpy(e, bb, sizeof(uint64_t) * 4);
    f_255_19_additive_inverse(e);
    f_255_19_add(e, aa); // E = AA-BB
    memcpy(c, x3, sizeof(uint64_t) * 4);
    f_255_19_add(c, z3); // C = X3 + Z3
    memcpy(d, z3, sizeof(uint64_t) * 4);
    f_255_19_additive_inverse(d);
    f_255_19_add(d, x3); // D = X3-Z3
    memcpy(da, d, sizeof(uint64_t) * 4);
    f_255_19_multiply(da, a); // DA = D*A
    memcpy(cb, c, sizeof(uint64_t) * 4);
    f_255_19_multiply(cb, b); // CB = C*B
    memcpy(x3, da, sizeof(uint64_t) * 4);
    f_255_19_add(x3, cb);
    f_255_19_multiply(x3, x3); // X3 = (DA+CB)^2
    memcpy(z3, cb, sizeof(uint64_t) * 4);
    f_255_19_additive_inverse(z3);
    f_255_19_add(z3, da);
    f_255_19_multiply(z3, z3);
    f_255_19_multiply(z3, x); // Z3 = X*(DA-CB)^2
    memcpy(x2, aa, sizeof(uint64_t) * 4);
    f_255_19_multiply(x2, bb); // X2 = AA*BB
    z2[0] = z2[1] = z2[2] = 0x0; z2[3] = 121665;
    f_255_19_multiply(z2, e);
    f_255_19_add(z2, aa);
    f_255_19_multiply(z2, e); // Z2 = E*(AA+121666*E)
  }
  cswap(swap, x2, z2, x3, z3);
  memcpy(x, x2, sizeof(uint64_t) * 4);
  memcpy(z, z2, sizeof(uint64_t) * 4);
}
@

If we interpret the group of points on the elliptic curve as a
multiplicative group rather than an additive one, then scalar
multiplication becomes viewed as exponentiation. This is the most
common convention in cryptography, where such exponentiation is said
to be hard to reverse and equivalent to the problem of computing the
discrete logarithm.

Because of this, a fairly common cryptographic operation is to
generate a random exponent (which, for security purposes, must be a
multiple of 8, less than $2^{255}$, and greater than $2^{254} -
1$). The exponent is considered a secret key. Raising the point $x =
9$ to this exponent produces a public key. To compute such operations
more conveniently, we define the following function:

@<Auxiliary Local Functions (network.c)@>+=
void curve25519_keygen(uint64_t secret_key[4], uint64_t public_key[4]){
  uint64_t g[4], z[4];
  int i;
  g[0] = g[1] = g[2] = 0x0; g[3] = 0x9;
  z[0] = z[1] = z[2] = 0x0; z[3] = 0x1;
  for(i = 0; i < 4; i ++)
    secret_key[i] = random_function();
  secret_key[3] &= 0xfffffffffffffff8;
  secret_key[0] &= 0x7fffffffffffffff;
  secret_key[0] |= 0x4000000000000000;
  curve25519_mult(g, z, secret_key);
  f_255_19_multiplicative_inverse(z);
  f_255_19_multiply(g, z);
  memcpy(public_key, g, sizeof(uint64_t)* 4);
}
@

\secao{Protocols}

\subsecao{The TLS 1.3 Protocol}

The TLS 1.3 protocol is a protocol between two machines that fulfills
two objectives:

a) The two machines exchange a secret value that cannot be
intercepted, even if the communication channel is insecure. This
secret can be used to derive symmetric keys for message encryption and
authentication.

b) The machines can prove their authenticity by presenting digital
certificates signed by authorities considered trustworthy, containing
their public keys and their identity. In our case, we will never do
this. However, we expect external servers to prove their identity in
this way so that we can be sure we are connecting to a trusted
machine.

A typical communication in this protocol involves two messages. First,
we send the server a message stating that we want to initiate the
protocol, informing it which algorithms we can use and also sending a
public key created by \monoespaco{curve25519_keygen}.

The server’s response is its digital certificate and its own public
key, also generated by its \monoespaco{curve25519_keygen} or an
equivalent function. We can ensure that the server is who it claims to
be by verifying its certificate and using its public key to verify the
digital signature it made over a digest of the messages we
exchanged. If the server passes the test, we can obtain the shared
secret by multiplying its public key by the constant equal to our
private key using \monoespaco{curve25519_multiply}.

A ClientHello message that we generate will have a total of 208 bytes
plus the bytes needed to indicate the server name in the message. We
will construct it directly here:

@<Auxiliary Local Functions (network.c)@>+=
unsigned char *tls13_client_hello(char *hostname, uint64_t pk[4],
                                  size_t *msg_size){
 int i;
 uint64_t *p;
 unsigned char *hello;
 uint16_t hostname_size = strlen(hostname);
 *msg_size = 208 + hostname_size;
 hello = (unsigned char *) temporary_alloc(*msg_size);
 // Message type: handshake:
 hello[0] = 0x16;
 // Protocol version: 1.3:
 hello[1] = 0x03; hello[2] = 0x01;
 {  // Remaining message size:
   uint16_t size = *msg_size - 5;
   hello[3] = size / 256; hello[4] = size % 256;
 }
 // Message type: ClientHello:
 hello[5] = 0x01;
 { // ClientHello Size:
   uint32_t size = *msg_size - 9;
   hello[6] = (size >> 16) % 256; hello[7] = (size >> 8) % 256;
   hello[8] = size % 256;
 }
 // Client Version: We send TLS 1.2 for legacy support.
 // TLS 1.3 messages simulate TLS 1.2:
 hello[9] = hello[10] = 0x03;
 // 32 bytes of random data:
 p = ((uint64_t *) &(hello[11]));
 *p = random_function(); p ++;
 *p = random_function(); p ++;
 *p = random_function(); p ++;
 *p = random_function(); p ++;
 // Session data size: 32 bytes:
 hello[43] = 0x20;
 // Session data. Just random values 
 // to simulate  TLS 1.2:
  p = ((uint64_t *) &(hello[44]));
 *p = random_function(); p ++;
 *p = random_function(); p ++;
 *p = random_function(); p ++;
 *p = random_function(); p ++;
  // 2 bytes for data about encryption support:
  hello[76] = 0x0; hello[77] = 0x02;
  // We support: TLS_AES_128_GCM_SHA256
  hello[78] = 0x13; hello[79] = 0x01;
  // TLS 1.3 do not allow compression:
  hello[80] = 0x01; hello[81] = 0x00;
  // Extension size:
  {
    uint16_t size = *msg_size - 84;
    hello[82] = size / 256; hello[83] = size % 256;
  }
  // Extension: SNI: Host name
  hello[84] = hello[85] = 0x00;
  { // SNI size:
    uint16_t size = hostname_size + 5;
    hello[86] = size / 256; hello[87] = size % 256;
  }
  { // Size for the list below
    uint16_t size = hostname_size + 3;
    hello[88] = size / 256; hello[89] = size % 256; 
  }
  // First item in list is DNS Hostname:
  hello[90] = 0x00;
  {  // Hostname size
    uint16_t size = hostname_size;
    hello[91] = size / 256; hello[92] = size % 256;
  }
  // Copying hostname:
  memcpy(&(hello[93]), hostname, hostname_size);
  // Extension: Supported groups:
  hello[93 + hostname_size] = 0x00; hello[94 + hostname_size] = 0x0a;
  // Extension size: 22 bytes
  hello[95 + hostname_size] = 0x00; hello[96 + hostname_size] = 0x16;
  // List of curve size: 20 bytes:
  hello[97 + hostname_size] = 0x00; hello[98 + hostname_size] = 0x14;
  // Supported curves
  hello[99 + hostname_size] = 0x00; hello[100 + hostname_size] = 0x1d;
  hello[101 + hostname_size] = 0x00; hello[102 + hostname_size] = 0x17;
  hello[103 + hostname_size] = 0x00; hello[104 + hostname_size] = 0x1e;
  hello[105 + hostname_size] = 0x00; hello[106 + hostname_size] = 0x19;
  hello[107 + hostname_size] = 0x00; hello[108 + hostname_size] = 0x18;
  hello[109 + hostname_size] = 0x01; hello[110 + hostname_size] = 0x00;
  hello[111 + hostname_size] = 0x01; hello[112 + hostname_size] = 0x01;
  hello[113 + hostname_size] = 0x01; hello[114 + hostname_size] = 0x02;
  hello[115 + hostname_size] = 0x01; hello[116 + hostname_size] = 0x03;
  hello[117 + hostname_size] = 0x01; hello[118 + hostname_size] = 0x04;
  // Extension: Signature algorithms
  hello[119 + hostname_size] = 0x00; hello[120 + hostname_size] = 0x0d;
  // Extension size: 30 bytes
  hello[121 + hostname_size] = 0x00; hello[122 + hostname_size] = 0x1e;
  // Size for the list below: 28 bytes
  hello[123 + hostname_size] = 0x00; hello[124 + hostname_size] = 0x1c;
  // Signatures
  hello[125 + hostname_size] = 0x04; hello[126 + hostname_size] = 0x03;
  hello[127 + hostname_size] = 0x05; hello[128 + hostname_size] = 0x03;
  hello[129 + hostname_size] = 0x06; hello[130 + hostname_size] = 0x03;
  hello[131 + hostname_size] = 0x08; hello[132 + hostname_size] = 0x07;
  hello[133 + hostname_size] = 0x08; hello[134 + hostname_size] = 0x08;
  hello[135 + hostname_size] = 0x08; hello[136 + hostname_size] = 0x09;
  hello[137 + hostname_size] = 0x08; hello[138 + hostname_size] = 0x0a;
  hello[139 + hostname_size] = 0x08; hello[140 + hostname_size] = 0x0b;
  hello[141 + hostname_size] = 0x08; hello[142 + hostname_size] = 0x04;
  hello[143 + hostname_size] = 0x08; hello[144 + hostname_size] = 0x05;
  hello[145 + hostname_size] = 0x08; hello[146 + hostname_size] = 0x06;
  hello[147 + hostname_size] = 0x04; hello[148 + hostname_size] = 0x01;
  hello[149 + hostname_size] = 0x05; hello[150 + hostname_size] = 0x01;
  hello[151 + hostname_size] = 0x06; hello[152 + hostname_size] = 0x01;
  // Extension: Supported Versions
  hello[153 + hostname_size] = 0x00; hello[154 + hostname_size] = 0x2b;
  // Extension size: 3 bytes
  hello[155 + hostname_size] = 0x00; hello[156 + hostname_size] = 0x03;
  // TLS version size: 2 bytes
  hello[157 + hostname_size] = 0x02;
  // TLS 1.3:
  hello[158 + hostname_size] = 0x03; hello[159 + hostname_size] = 0x04;
  // Extension: PSK Key Exchange Modes
  hello[160 + hostname_size] = 0x00; hello[161 + hostname_size] = 0x2d;
  // Extension size: 2 bytes
  hello[162 + hostname_size] = 0x00; hello[163 + hostname_size] = 0x02;
  // Number of bytes for modes: 1  Mode: Diffie-Hellman 
  hello[164 + hostname_size] = 0x01; hello[165 + hostname_size] = 0x01;
  // Extension: Key Share
  hello[166 + hostname_size] = 0x00; hello[167 + hostname_size] = 0x33;
  // Extension size: 38 bytes
  hello[168 + hostname_size] = 0x00; hello[169 + hostname_size] = 0x26;
  // Size of key below: 36 bytes:
  hello[170 + hostname_size] = 0x00; hello[171 + hostname_size] = 0x24;
  // It is a x25519 key:
  hello[172 + hostname_size] = 0x00; hello[173 + hostname_size] = 0x1d;
  // The key has 32 bytes:
  hello[174 + hostname_size] = 0x00; hello[175 + hostname_size] = 0x20;
  // The key in little endian format:
  for(i = 0; i < 32; i ++){
    hello[176 + hostname_size + i] = (pk[3-(i/8)] >> ((i%8)*8)) % 256;
  }
  return hello;
}
@


\fim