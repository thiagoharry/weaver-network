\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver Network Module}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents an implementation, using literate
programming, of the network code required for secure synchronization
between different instances of a game or interactive software built on
the Weaver game engine. It covers both the message exchange mechanisms
and the cryptographic components responsible for ensuring
confidentiality, integrity, and mutual authentication among the
participating programs.}

\secao{1. Introduction}

\subsecao{1.1. Exported Functions}

The network module of the Weaver game engine defines and exports a set
of functions that can be used externally. We will list these functions
and their signatures here.

First, the initialization and shutdown functions. The initialization
function must be the first one called, before any other function
listed below. The shutdown function must be the last: after invoking
it, no other network function should be called (except the
initialization function to reinitialize this module). The
initialization function must also receive pairs of functions for
memory allocation and deallocation: one pair for temporary allocations
and another for permanent allocations. Adding this support for custom
memory managers is performed by all Weaver modules.

@<Function Declaration (network.h)@>=
void _Winit_network(void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *));
void _Wfinish_network(void);
@

To create a new connection (but not activate it yet), we use:

@<Function Declaration (network.h)@>+=
struct connection *_Wcreate_connection(void);
@

\subsecao{1.2. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{network.h}.

We show below the structure of the file \monoespaco{network.h}:

@(src/network.h@>=
#ifndef __WEAVER_NETWORK
#define __WEAVER_NETWORK
#ifdef __cplusplus
extern "C" {
#endif
#include <stdlib.h> // Standard library
//@<Include General Headers (network.h)@>
//@<General Macros (network.h)@>
//@<Data Structures (network.h)@>
@<Function Declaration (network.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

The code above shows the default boilerplate for defining a header in
our C API. The first two lines and the last one are macros that ensure
the header is not included more than once in a single compilation
unit. Lines 3, 4, 5, and the three lines before the last one make the
header compatible with C++ code. These lines tell the compiler that we
are using C code and, therefore, it can apply optimizations assuming
that no C++-specific features---such as operator overloading---will be
used.

Next, we include a header that allows us to use boolean variables. You
may also notice some parts highlighted in red. One of them is labeled
``Function Declaration (network.h)'', the same title used for most of
the code declared earlier. This means that all previously defined code
blocks with that title will be inserted at this point in the file. The
other red-highlighted parts represent code that we will define in the
following sections.

If you want to understand how the \monoespaco{network.c} file
relates to this header, its structure is as follows:

@(src/network.c@>=
#include "network.h"
#if defined(__EMSCRIPTEN__)
#include <emscripten.h>
#endif
@<Local Headers (network.c)@>
//@<Local Macros (network.c)@>
//@<Local Data Structures (network.c)@>
@<Local Variables (network.c)@>
@<Auxiliary Local Functions (network.c)@>
@<API Functions Definition (network.c)@>
@

All the code presented in this document will be placed in one of these
two files. No other files will be created.

\secao{2. Newtwork Module Initialization}

The first part of the code we will introduce consists of the
network-related headers. On Windows, the library used is
``winsock2''. This library must also be linked externally to the
program, but this can be done using a ``pragma'' directive for the
compiler:

@<Local Headers (network.c)@>=
#if defined(_WIN32)
#include <winsock2.h>
#pragma comment(lib,"wsock32.lib")
#endif
@

On Unix-based systems, we only need to include the appropriate
headers. The ability to establish connections is already part of the
standard libraries and does not require linking with external
libraries:

@<Local Headers (network.c)@>+=
#if defined(__unix__)
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#endif
@

If we are running WebAssembly in a web browser, network connections
must be made using the browser's own capabilities, and this does not
require any special headers.

In most environments, no special initialization is required before
using functions to establish network connections. However, there are
exceptions (Windows, for example), and for this reason, it is
important to have a function that handles the initialization of the
network module. This function performs initialization on systems where
it is needed. On other systems, initialization is still important, but
only for storing our allocation and deallocation functions.

@<Local Headers (network.c)@>+=
#include <stdlib.h> // Require: 'malloc', 'free'
@

@<Local Variables (network.c)@>=
// By default, the allocation and deallocation functions are from stdlib.
// But the initialization below may change this:
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@

@<API Functions Definition (network.c)@>=
void _Winit_network(void *(*p_alloc)(size_t), void (*p_free)(void *),
                    void *(*t_alloc)(size_t), void (*t_free)(void *)){
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  temporary_alloc = t_alloc;
  temporary_free = t_free;  
#if defined(_WIN32) // Windows:
  WSADATA WsaData;
  WSAStartup(MAKEWORD(2,2), &WsaData);
#endif
  //@<Weaver Network: Initialization@>
  return;
}
@

Systems that require additional initialization to use the network may
also require a shutdown procedure, which is invoked below:

@<API Functions Definition (network.c)@>+=
void _Wfinish_network(void){
#if defined(_WIN32) // Windows:
  WSACleanup();
#endif
  return;
}
@

\secao{3. Network Primitives}

\subsecao{3.1. Identifying an Address}

Before starting any type of connection, we must be able to know which
address we should connect to. Addresses can be the IPs of other
machines in IPv4 or IPv6. They can also be a domain name.

The rules we will adopt to identify the type of address are based on
RFC 3986:

\alinhaverbatim
<address>         -> <host>
<host>             -> <IPv6 address>
                      <IPv4 address> |
	              <Register Name>
<IPv4 address>    -> <Decimal Octet> "." <Decimal Octet> "." <Decimal Octet>
                      "." <Decimal Octet>
<IPv6 address>    -> Complex rules to be defined. But they alway contain ":".
<Decimal Octet>   -> Number between 0 and 255 (inclusive). With no leading zeroes.
<Register Nmae> -> Any amount of letters, digits and several symols,
                   but without ":", "[" and "]"
\alinhanormal

We therefore need a function that takes an integer and returns an integer representing an address type. The return value will be -1 if the address is not valid, 1 if it is IPv4, 2 if it is IPv6, and 3 if it is a domain name.

The function will work by storing a variable
\monoespaco{may_be_ipv4} which will be initialized as true, but will become false as soon as we find something that indicates what we have cannot be an IPv4. This is because there is ambiguity in the rules for defining a domain name and an IPv4, but as long as something can be interpreted as IPv4, this must be the preferred interpretation.

To identify what type of address we have, we will iterate over each character of the address. As soon as we find a colon (“:”), the address can only be IPv6. We interrupt the entire computation and return. As soon as we find a lowercase or uppercase letter above “f” or “F”, we can assume with absolute certainty that we have a hostname (domain name).

If we reach the end of our loop and identify that the address may be an IPv4, then it will be an IPv4. Otherwise, it will be a domain name (an IPv6 always has a “:”, so we return from our function before the end of the loop if we find such a character).

While our address may still be an IPv4, we count the characters we receive up to the next dot and concatenate them into a buffer. If we read more than 3 characters, it certainly won’t be an IPv4. If the character is not numeric, it won’t be IPv4. If we read 2 or 3 characters that have a leading zero, it also won’t be IPv4. If the characters cannot be converted into a number between 0 and 255, it won’t be IPv4 either.

Here is our code:

@<Auxiliary Local Functions (network.c)@>=
#define ADDRESS_TYPE_INVALID -1
#define ADDRESS_TYPE_IPV4     1
#define ADDRESS_TYPE_IPV6     2
#define ADDRESS_TYPE_DOMAIN   3
int detect_address_type(char *address){
  bool may_be_ipv4 = true;
  char buffer[4], *c;
  int number_of_chars_before_point = 0;
  if(address[0] == '\0')
    return ADDRESS_TYPE_INVALID;
  for(c = address; *c != '\0'; c ++){
    if(*c == ':')
      return ADDRESS_TYPE_IPV6;
    if((*c > 'f' && *c <= 'z') || (*c > 'F' && *c <= 'Z'))
      return ADDRESS_TYPE_DOMAIN;
    if(may_be_ipv4){
      if(*c == '.'){
        int num;
        if(number_of_chars_before_point < 1 ||
	   number_of_chars_before_point > 3){
          may_be_ipv4 = false;
          continue;
        }
	if(number_of_chars_before_point > 1 && buffer[0] == '0'){
          may_be_ipv4 = false;
          continue;
        }
	buffer[number_of_chars_before_point] = '\0';
	num = atoi(buffer);
	if(num > 255){
          may_be_ipv4 = false;
          continue;
        }
	number_of_chars_before_point = 0;
	continue;
      }
      if(*c < '0' || *c > '9'){
        may_be_ipv4 = false;
	continue;
      }
      buffer[number_of_chars_before_point] = *c;
      number_of_chars_before_point ++;
      if(number_of_chars_before_point > 3){
        may_be_ipv4 = false;
	continue;
      }
    }
  }
  if(may_be_ipv4)
    return ADDRESS_TYPE_IPV4;
  else
    return ADDRESS_TYPE_DOMAIN;
}
@

\fim