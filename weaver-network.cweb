\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Módulo de Rede Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents an implementation, using literate
programming, of the network code required for secure synchronization
between different instances of a game or interactive software built on
the Weaver game engine. It covers both the message exchange mechanisms
and the cryptographic components responsible for ensuring
confidentiality, integrity, and mutual authentication among the
participating programs.}

\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo apresenta uma implementação, utilizando
programação literária, do código de rede necessário para a
sincronização segura entre diferentes instâncias de um jogo ou
software interativo baseado no motor de jogos Weaver. São abordados
tanto os mecanismos de troca de mensagens quanto os componentes
criptográficos responsáveis por garantir confidencialidade,
integridade e autenticação mútua entre os programas participantes.}

\secao{1. Introdução}

\subsecao{1.1. Funções a Serem Exportadas}

O módulo de rede do motor de jogos Weaver atua definindo e exportando
uma série de funções que podem ser usadas externamente. Listaremos
aqui as funções e suas assinaturas.

Primeiro a função de inicialização e finalização. A inicialização deve
ser a primeira função a ser chamada, antes de qualquer outra função a
ser mostrada abaixo. Após invocar a finalização, não se deve chamar
novamente nenhuma outra função definida aqui (exceto a função de
inicialização caso queira-se voltar a inicializar o módulo). A função
de inicialização também deve receber pares de função que fazem
alocação e desalocação de memória. Um par para alocações temporárias e
outro para alocações permanentes. Adicionar este tipo de suporte a
gerenciadores de memória personalizados é algo que todo módulo Weaver
faz.

@<Declaração de Função (network.h)@>=
void _Winit_network(void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *));
void _Wfinish_network(void);
@

Para gerar uma nova conexão (mas ainda não ativá-la), usamos:

@<Declaração de Função (network.h)@>+=
struct connection *_Wcreate_connection(void);
@

\subsecao{1.2. Programação Literária}

Nosso código será escrito usando técnica de programação literária
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{network.h}.

Podemos apresentar aqui a estrutura do arquivo \monoespaco{network.h}:

@(src/network.h@>=
#ifndef __WEAVER_NETWORK
#define __WEAVER_NETWORK
#ifdef __cplusplus
extern "C" {
#endif
#include <stdlib.h> // Biblioteca padrão
//@<Inclui Cabeçalhos Gerais (network.h)@>
//@<Macros Gerais (network.h)@>
//@<Estrutura de Dados (network.h)@>
@<Declaração de Função (network.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (network.h)'', o mesmo nome apresentado no trecho de
código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{network.c}
associado a este cabeçaho, o código será este:

@(src/network.c@>=
#include "network.h"
#if defined(__EMSCRIPTEN__)
#include <emscripten.h>
#endif
#include <stdbool.h> // Suporte a tipos booleanos
#include <string.h>  // Usaremos 'memset'
#include <unistd.h>  // Usaremos 'close'
@<Cabeçalhos Locais (network.c)@>
//@<Macros Locais (network.c)@>
//@<Estrutura de Dados Locais (network.c)@>
@<Variáveis Locais (network.c)@>
@<Funções Auxiliares Locais (network.c)@>
@<Definição de Funções da API (network.c)@>
@


Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. Inicialização do Módulo de Rede}

A primeira parte do código que vamos introduzir são os cabeçalhos de
uso da rede. No Windows, a biblioteca usada é o ``winsock2''. Essa
biblioteca também deve ser ligada externamente ao programa, mas isso
pode ser feito com uma diretiva ``pragma'' para o compilador:

@<Cabeçalhos Locais (network.c)@>=
#if defined(_WIN32)
#include <winsock2.h>
#pragma comment(lib,"wsock32.lib")
#endif
@

Em sistemas baseados em Unix, só precisamos incluir os cabeçalhos
adequados. A capacidade de se conectar já faz parte das bibliotecas
padrão e não requer a ligação com bibliotecas externas:

@<Cabeçalhos Locais (network.c)@>+=
#if defined(__unix__)
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#endif
@

Se estivermos executando WebAssembly em um navegador de Internet, a
conexão de rede deve sr feita usando recursos do próprio navegador, e
isso não requer cabeçalhos especiais.

Na maioria dos ambientes, não é necessário realizar nenhum tipo de
inicialização especial antes de usar as funções para estabelecer
conexões de rede. Mas há exceções (o Windows, por exemplo), e por
causa disso é importante existir uma função que cuida da inicialização
do módulo de rede. Tal função faz a inicialização nos sistemas em que
isso é necessário. Nos demais sistemas, a inicialização ainda é
importante, mas apenas para armazenarmos as nossas funções de alocação
e desalocação.

@<Cabeçalhos Locais (network.c)@>+=
#include <stdlib.h> // Requer: 'malloc', 'free'
@

@<Variáveis Locais (network.c)@>=
// Por padrão as funções de alocação serão as da biblioteca padrão.
// Mas a inicialização pode modificar o valor padrão delas:
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@

@<Definição de Funções da API (network.c)@>=
// A função de inicialização:
void _Winit_network(void *(*p_alloc)(size_t), void (*p_free)(void *),
                    void *(*t_alloc)(size_t), void (*t_free)(void *)){
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  temporary_alloc = t_alloc;
  temporary_free = t_free;  
#if defined(_WIN32) // Windows:
  WSADATA WsaData;
  WSAStartup(MAKEWORD(2,2), &WsaData);
#endif
  //@<Weaver Network: Inicialização@>
  return;
}
@

Sistemas que requerem uma inicialização adicional para usar a rede
podem precisar também de uma finalização, que é invocada abaixo:

@<Definição de Funções da API (network.c)@>+=
void _Wfinish_network(void){
#if defined(_WIN32) // Windows:
  WSACleanup();
#endif
  return;
}
@

\secao{3. Primitivas de Rede}

\subsecao{3.1. Identificando um Endereço}

Antes de iniciarmos qualquer tipo de conexão, devemos ser capazes de
saber a qual endereço devemos nos conectar. Endereços podem ser IPs de
outras máquinas em IPv4 ou IPv6. Podem ser também um nome de domínio.

As regras que adotaremos para identificar o tipo de endereço são
baseadas no RFC 3986:

\alinhaverbatim
<endereço>         -> <host>
<host>             -> <Endereço IPv6>
                      <Endereço IPv4> |
                      <Nome de Registro>
<Endereço IPv4>    -> <Octeto Decimal> "." <Octeto Decimal> "." <Octeto Decimal>
                      "." <Octeto Decimal>
<Endereço IPv6>    -> Regras elaboradas a estabelecer. Mas sempre contém ":".
<Octeto Decimal>   -> Número entre 0 e 255 (inclusive). Sem zeros à esquerda.
<Nome de Registro> -> Qualquer quantidade de letras, dígitos, caracteres e
                      diversos símbolos, mas sem ":", "[" e "]"
\alinhanormal

Precisamos então de uma função que recebe um inteiro e retorna um
inteiro representando um tipo de endereço. O retorno será -1 se o
endereço não for válido, 1 se for um IPv4, 2 se for IPv6 e 3 se for um
nome de domínio.

A função funcionará armazenando uma variável
\monoespaco{may\_be\_ipv4} que será inicializada como verdadeira, mas
se tornará falsa assim que encontrarmos algo que indica que o que
temos não pode ser um IPv4. Isso ocorre porque existe ambigüidade nas
regras de como definir um nome de domínio e um IPv4, mas enquanto algo
puder ser interpretado como IPv4, esta deve ser a interpretação
preferencial.

Para identificarmos que tipo de endereço temos, iremos iterar sobre
cada caractere do endereço. Tão logo encontramos um caractere de dois
pontos (``:''), o endereço sópode ser IPv6. Interrompemos toda a
computação e retornamos. Assim que encontramos uma letra minúscula ou
maiúscula acima de ``f'' ou ``F'', podemos assumir com certeza
absoluta que temos um nome de registro (domínio).

Se chegarmos até o fim do nosso loop e identificarmos que o endereço
pode ser um IPv4, ele será um IPv4. Caso contrário, ele será um nome
de registro de domínio (um IPv6 sempre tem um ``:'', então retornamos
de nossa função antes do fim do loop se encontrarmos tal caractere).

Enquanto nosso endereço pode ser um IPv4, contamos os caracteres que
recebemos até o próximo ponto e os concatenamos em um buffer. Se
lermos mais de 3 caracteres, certamente não será um IPv4. Se o
caractere não for numérico, não será IPv4. Se lermos 2 ou 3 caracteres
que tenham um zero à esquerda, também não será IPv4. Se os caracteres
não puderem ser convertidos para um número entre 0 e 255, também não
será IPv4.

Eis agora o nosso código:


@<Funções Auxiliares Locais (network.c)@>=
#define ADDRESS_TYPE_INVALID -1
#define ADDRESS_TYPE_IPV4     1
#define ADDRESS_TYPE_IPV6     2
#define ADDRESS_TYPE_DOMAIN   3
int detect_address_type(char *address){
  bool may_be_ipv4 = true;
  char buffer[4], *c;
  int number_of_chars_before_point = 0;
  if(address[0] == '\0')
    return ADDRESS_TYPE_INVALID;
  for(c = address; *c != '\0'; c ++){
    if(*c == ':')
      return ADDRESS_TYPE_IPV6;
    if((*c > 'f' && *c <= 'z') || (*c > 'F' && *c <= 'Z'))
      return ADDRESS_TYPE_DOMAIN;
    if(may_be_ipv4){
      if(*c == '.'){
        int num;
        if(number_of_chars_before_point < 1 ||
	   number_of_chars_before_point > 3){
          may_be_ipv4 = false;
          continue;
        }
	if(number_of_chars_before_point > 1 && buffer[0] == '0'){
          may_be_ipv4 = false;
          continue;
        }
	buffer[number_of_chars_before_point] = '\0';
	num = atoi(buffer);
	if(num > 255){
          may_be_ipv4 = false;
          continue;
        }
	number_of_chars_before_point = 0;
	continue;
      }
      if(*c < '0' || *c > '9'){
        may_be_ipv4 = false;
	continue;
      }
      buffer[number_of_chars_before_point] = *c;
      number_of_chars_before_point ++;
      if(number_of_chars_before_point > 3){
        may_be_ipv4 = false;
	continue;
      }
    }
  }
  if(may_be_ipv4)
    return ADDRESS_TYPE_IPV4;
  else
    return ADDRESS_TYPE_DOMAIN;
}
@

\subsecao{Conectando a um Endereço}

Quando nos conectamos a outra máquina, precisamos saber o seu
endereço, a sua porta e se a conexão deve ser feita via TCP ou
UDP. Para isso iremos definir uma função que recebe como argumento
estas três informações, cria um socket e se conecta a ele abrindo uma
conexão com a máquina indicada.

A função irá receber os seguintes valores como entrada:

1) ``address'': Um endereço. Que é uma string com um endereço IPv4,
IPv6 ou um nome de domínio.

2) ``port'': Uma string contendo um número de porta escrito com
algarismos decimais. Ou, alternativamente, o nome de um protocolo
reconhecido pelo Sistema Operacional em que estamos executando caso
queiramos que o Sistema Operacional indique a porta correta.

3) Um valor que pode ser SOCK\_STREAM (TCP) ou SOCK\_DGRAM (UDP).

O valor de retorno será um inteiro que é o idendificador de um socket
que foi aberto e está conectado ao endereço indicado. Ou -1 caso não
tenha sido possível se conectar.

Para implementarmos isso, iremos confiar na função ``getaddrinfo'' que
fará a maior parte do trabalho de interpretar o endereço indicado e
gerar estruturas que podem então ser usadas pela função de sistema
``connect'':


@<Funções Auxiliares Locais (network.c)@>=
int connect_socket(char *address, char *port, int type){
  struct addrinfo hints;
  int s, sfd;
  struct addrinfo *result, *rp;
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;    /* IPv4 ou IPv6 */
  hints.ai_socktype = type;
  s = getaddrinfo(address, port, &hints, &result);
  if(s != 0)
    return -1;
  for (rp = result; rp != NULL; rp = rp->ai_next) {
    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if(sfd == -1)
      continue;
    if(connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
      break; /* Sucesso */
    close(sfd);
  }
  freeaddrinfo(result); /* Desalocando */
  if(rp == NULL)
    return -1;
  return sfd;
}
@

\secao{Primitivas Matemáticas}

\subsecao{O Corpo Finito Módulo $2^{255}-19$}

Uma parte considerável das operações criptográficas que realizaremos
ocorrem em um corpo finito. Isto é, em uma estrutura matemática onde
podemos realizar multiplicações e adições, mas onde o conjunto de
elementos que podem ser somados e multiplicados é um número finito. No
nosso caso, será um conjunto formado pelos inteiros que vãodo zero até
$2^{255}-20$.

A soma e a multiplicação sobre tais números inteiros vão se comportar
de maneira muito semelhante à que estamos habituados quando lidamos
com números inteiros comuns. Entretanto, após realizar qualquer
operação, a resposta final é obtida dividindo o resultado por
$2^{255}-19$ e substituindo o resultado obtido pelo resto desta
divisão. Desta forma, a realização de qualquer operação matemática
usual sempre será contida dentro de nosso intervalo finito.

Por exemplo, a soma: $(2^{255}-20) + (1) = 0$. Pois o resultado desta
soma se estivéssemos em um conjunto infinito de inteiros seria
$2^{255}-20$. Mas este valor é maior do que podemos representar no
nosso conjunto finito. Sendo assim, ele é substituído pelo resto da
sua divisão por $2^{255}-19$, o que é zero.

Cada elemento de nosso corpo finito pode ser representado dentro de
vetores com quatro inteiros sem sinal de 64 bits. Esta será então a
forma que escolheremos para representar os elementos deste corpo
finito.

Desta forma, o elemento zero de nosso grupo será:

\alinhaverbatim
{UINT64\_C(0x0), UINT64\_C(0x0), UINT64\_C(0x0), UINT64\_C(0x0)}
\alinhanormal

Enquanto o maior valor será:

\alinhaverbatim
{UINT64\_C(0x7fffffffffffffff), UINT64\_C(0xffffffffffffffff),
 UINT64\_C(0xffffffffffffffff), UINT64\_C(0xffffffffffffffec)}
\alinhanormal

Como o bit mais significativo de toda a nossa lista sempre será zero
para elementos de nosso grupo, isso significa que podemos sempre somar
dois elementos do grupo e armazenar o resultado em um vetor de 4
inteiros sem sinal de 64 bits, sem que ocorra um ``overflow'' que não
possamos armazenar na estrutura.

Podemos então somar dois valores usando a operação abaixo (que ainda
está incompleta porque não se preocupa quando o resultado se torna
maior do que o que pode ser representado no grupo):

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_incomplete_add(uint64_t *destiny, uint64_t *sum, int size){
  int i;
  uint64_t initial_value;
  int carry = 0;
  for(i = size - 1; i >= 0; i --){
    initial_value = destiny[i];
    destiny[i] += sum[i] + carry;
    carry = (destiny[i] < initial_value);
    carry += ((destiny[i] == initial_value) * (sum[i] != 0));
  }
}
@

De agora em diante, chamaremos o grupo de inteiros entre 0 e
$2^{255}-19$ de $F_{2^{255}-19}$. Ou \monoespaco{f\_255\_19} quando
queremos nor referir ao grupo no código, como foi feito na função
acima.

Este grupo tem uma característica que o torna cômodo para ser usado em
operações em grupo. Quando fazemos uma operação de dois elementos
dele, pode ser que podemos obter um valor maior que $2^{255}-19$, o
que significa que o valor precisa ser normalizado de volta para dentro
do grupo. Mas como:

$$
2^{255}\equiv 19 (mod\,\,2^{255}-19)
$$

Então qualquer múltiplo de $2^{255}$ pode ser substituído por um
múltiplo de 19. Em suma, se obtivermos em uma soma um valor onde o
último bit estiver ativo (ou seja, o bit correspondente a $2^{255}$),
podemos então apenas marcar esse bit como zero e somar o restante do
número com 19. E repetir o processo enquanto o último bit ainda
estiver ativo. Depois, basta checar se o valor resultante está dentro
dos limites do grupo. Se não estiver, existem apenas 19 valores
inválidos que possuem o último bit igual a zero. Tratar eles é apenas
uma questão de ajustar para zero os 3 números de 64 bits mais
significativos e trocar o menos significativo pelo valor atual menos
$0xffffffffffffffed$.

O código que faz isso é:

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_normalize(uint64_t n[4]){
  int still_big;
  uint64_t nineteen[4];
  nineteen[0] = 0x0;
  nineteen[1] = 0x0;
  nineteen[2] = 0x0;
  nineteen[3] = 0x0;
  nineteen[3] = 19 * ((n[0] & 0x8000000000000000) == 0x8000000000000000);
  n[0] = (n[0] & 0x7fffffffffffffff);
  f_255_19_incomplete_add(n, nineteen, 4);
  still_big = ((n[0] == 0x7fffffffffffffff) * (n[1] == ~0x0) * 
               (n[2] == ~0x0) * (n[3] > 0xffffffffffffffec));
  n[0] -= n[0] * still_big;
  n[1] -= n[1] * still_big;
  n[2] -= n[2] * still_big;
  n[3] -= 0xffffffffffffffed * still_big;
}
@

Note que o código acima faz o que descrevemos antes, mas de uma forma
um pouco mais complicada. Sem usar condicionais, e fazendo com que
toda iteração ocorra um número fixo de vezes. Isso é necessário em
código criptográfico para garantir que informação não seja vazada para
qualquer atacante por meio da diferença de tempo de execução na
execução de um algoritmo. Por este motivo, também evitamos operadores
lógicos AND e OR para evitar curto-circuito na avaliação: quando ã
expressão não é inteiramente avaliada porque o seu valor se torna
evidente após as priemiras operações.

De posse das funções de soma incompleta e de normalização, podemos
implementar a função que efetivamente soma dois elementos de um grupo,
gerando um terceiro elemento:

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_add(uint64_t a[4], uint64_t b[4]){ // a = a + b
  f_255_19_incomplete_add(a, b, 4);
  f_255_19_normalize(a);
}
@

Para fazer a subtração, basta calcular qual é o inverso aditivo de um
elemento do grupo, não precisamos de uma função de subtração. Para
obter o inverso aditivo, basta obter o maior elemento do grupo,
subtrair o elemento dele e somar 1.

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_additive_inverse(uint64_t n[4]){ // n = -n
  uint64_t biggest[4], one[4], initial;
  int i, carry = 0;
  biggest[0] = 0x7fffffffffffffff;
  biggest[1] = 0xffffffffffffffff;
  biggest[2] = 0xffffffffffffffff;
  biggest[3] = 0xffffffffffffffec;
  one[0] = one[1] = one[2] = 0;
  one[3] = 1;
  for(i = 3; i >= 0 ; i --){
    initial = n[i];
    n[i] = biggest[i] - n[i] - carry;
    carry = (n[i] > biggest[i]);
    carry = (n[i] == biggest[i]) * (initial != 0);
  }
  f_255_19_add(n, one);
}
@

Antes de partir para a multiplicação, vamos nos preparar antes criando
outra função de normalização. Mais acima criamos uma função que recebe
um número de 256 bits e o transforma para sua versão módulo
$2^{255}-19$, e que tal transformação pe necessária para calcular
corretamente a soma de números em nosso corpo finito. Para a
multiplicação vamos precisar tambpem de uma função de normalização que
faz o mesmo para números com 510 bits.

Para normalizarmos tais números, novamente iremos levar em conta a
propriedade de que $2^{255}$ é igual a 19 no módulo $2^{255}-19$. Note
que um número de 512 bits é representado pela sequência:

$$ (b_{509}, \ldots b_{256}, b_{255}, b_{254},
\ldots, b_0) $$

Que pode ser escrito como:

$$(b_{509}, \ldots, b_{255})\times19 + (b_{254}, \ldots, b_0) $$

Com isso, podemos escrever a função de normalização:

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_normalize2(uint64_t src[8], uint64_t dst[4]){
  // Copiando de b_0 a b_{254}:
  dst[3] = src[7];
  dst[2] = src[6];
  dst[1] = src[5];
  dst[0] = src[4] & 0x7fffffffffffffff;
  // Tratando os bits entre b_{255} e b_{509}:
  {
    int i;
    uint64_t aux[4], aux_copy[4];
    aux[3] = (src[4] >> 63); //b_{255}
    aux[3] += (src[3] << 1); // Bits b_{256} a b_{318}
    aux[2] = (src[3] >> 63); // b_{319}
    aux[2] += (src[2] << 1); // Bits b_{320} a b_{382}
    aux[1] = (src[2] >> 63); // b_{383}
    aux[1] += (src[1] << 1); // Bits b_{384} a b_{446}
    aux[0] = (src[1] >> 63); // b_{447}
    aux[0] += ((src[0] << 2) >> 1); // b_{448} a b_{509}
    memcpy(aux_copy, aux, sizeof(uint64_t) * 4);
    for(i = 0; i < 4; i ++){ // Multiplica aux por 16
      f_255_19_add(aux, aux);
    }
    for(i = 0; i < 3; i ++){ // Termina de calcular aux * 19
      f_255_19_add(aux, aux_copy);
    }
    f_255_19_add(dst, aux); // Adiciona ao resultado
  }
}
@

Agora vamos à multiplicação. Primeiro escrevemos um algoritmo que
realiza a multiplicação de dois números de 256 bits resultando em um
número de 512 bits. Mais tarde normalizaremos o resultado para que
tenhamos o valor dentro de nosso corpo:

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_incomplete_multiply(uint64_t a[4], uint64_t b[4], uint64_t r[8]){
  bool little_endian = true; // TODO: Set in initialization
  uint64_t aux[8];
  uint32_t a32[8], b32[8], aux32[16], carry;
  int i, j;
  memset(r, 0, sizeof(uint64_t) * 8);
  // Converte 'a' e 'b' para vetor uint32_t:
  memcpy(a32, a, sizeof(uint64_t) * 4);
  memcpy(b32, b, sizeof(uint64_t) * 4);
  if(little_endian){
    for(i = 0; i < 8; i += 2){
      uint32_t tmp = a32[i];
      a32[i] = a32[i + 1];
      a32[i + 1] = tmp;
      tmp = b32[i];
      b32[i] = b32[i + 1];
      b32[i + 1] = tmp;
    }
  }
  for(i = 7; i >= 0; i --){ // Algoritmo de multiplicação
    memset(aux32, 0, sizeof(uint32_t) * 16);
    carry = 0;
    for(j = 7; j >= 0; j --){
      uint64_t result = ((uint64_t) a32[j]) * ((uint64_t) b32[i]) + carry;
      carry = (uint32_t) (result / 0x100000000);
      aux32[1 + i + j ] = result % 0x100000000;
    }
    aux32[1 + i + j] = carry;
    if(little_endian){ // Converte multiplicação intermediária para uint64_t
      for(j = 0; j < 16; j += 2){
        uint32_t tmp = aux32[j];
        aux32[j] = aux32[j + 1];
        aux32[j + 1] = tmp;
      }
    }
    memcpy(aux, aux32, sizeof(uint64_t) * 8);
    f_255_19_incomplete_add(r, aux, 8); // Soma ao resultado
  }
}
@

E uma vez que temos um algoritmo de multiplicação para números de 256
bits que produz um número de 512 bits, podemos usar a nossa função de
normalização para finalizar a função de multiplicação no nosso corpo
finito:

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_multiply(uint64_t a[4], uint64_t b[4]){ // a = a * b
  uint64_t aux[8];
  f_255_19_incomplete_multiply(a, b, aux);
  f_255_19_normalize2(aux, a);
}
@

A próxima operação será calcular o inverso multiplicativo. Ou seja,
dado o número $n$, descobrir o valor de $n^{-1}$ tal que:

$$
n\cdot n^{-1} = 1 \pmod{2^{255}-19}
$$

A forma mais segura de calcular isso em tempo constante é calculando
$n^{2^{255}-21}$. Pois a ordem deste grupo é $2^{255}-20$. Portanto,
no módulo $2^{255}-19$ temos que $n^{-1}= n^{2^{255}-21}$.

Uma forma conhecida de realizar tal exponenciação é calcular
sucessivos valores na forma $n^{2^i-1}$, tentando sempre que possível
se aproximar do valor desejado por meio de sucessivas multiplicações
de um número por ele mesmo (elevar ao quadrado), e multiplicando por
termos calculados previamente para chegar ao valor. Uma forma de fazer
isso usando apenas 267 multiplicações pode ser vista na implementação
abaixo:

@<Funções Auxiliares Locais (network.c)@>+=
void f_255_19_multiplicative_inverse(uint64_t g[4]){ // g = 1/g
  int i;
  uint64_t t0[4], t1[4], t2[4], t3[4], t4[4], t5[4], t6[4], t7[4], z[4], g2[4];
  memcpy(t0, g, sizeof(uint64_t) * 4);
  f_255_19_multiply(t0, t0);
  memcpy(g2, t0, sizeof(uint64_t) * 4); //g2 = g^2
  f_255_19_multiply(t0, g); // t0 = g^(2^2 - 1) = g^3
  memcpy(z, t0, sizeof(uint64_t) * 4);
  f_255_19_multiply(z, z);
  f_255_19_multiply(z, g); // z = g^7
  memcpy(t1, z, sizeof(uint64_t) * 4);
  for(i = 0; i < 2; i ++)
    f_255_19_multiply(t1, t1);
  f_255_19_multiply(t1, t0); // t1 = g^(2^5 - 1) = g^31
  f_255_19_multiply(z, g2); // z = g^9
  f_255_19_multiply(z, g2); // z = g^11
  memcpy(t2, t1, sizeof(uint64_t) * 4);
  for(i = 0; i < 5; i ++)
    f_255_19_multiply(t2, t2);
  f_255_19_multiply(t2, t1); // t2 = g^(2^10 - 1) = g^1023
  memcpy(t3, t2, sizeof(uint64_t) * 4);
  for(i = 0; i < 10; i ++)
    f_255_19_multiply(t3, t3);
  f_255_19_multiply(t3, t2); // t3 = g^(2^20 -1)
  memcpy(t4, t3, sizeof(uint64_t) * 4);
  for(i = 0; i < 20; i ++)
    f_255_19_multiply(t4, t4);
  f_255_19_multiply(t4, t3); // t4 = g^(2^40 -1)
  for(i = 0; i < 10; i ++)
    f_255_19_multiply(t4, t4);
  f_255_19_multiply(t4, t2); // t4 = g^(2^50 -1)
  memcpy(t5, t4, sizeof(uint64_t) * 4);
  for(i = 0; i < 50; i ++)
    f_255_19_multiply(t5, t5);
  f_255_19_multiply(t5, t4); // t5 = g^(2^100 -1)
  memcpy(t6, t5, sizeof(uint64_t) * 4);
  for(i = 0; i < 100; i ++)
    f_255_19_multiply(t6, t6);
  f_255_19_multiply(t6, t5); // t6 = g^(2^200 -1)
  memcpy(t7, t6, sizeof(uint64_t) * 4);
  for(i = 0; i < 50; i ++)
    f_255_19_multiply(t7, t7);
  f_255_19_multiply(t7, t4); // t7 = g^(2^250 -1)
  memcpy(g, t7, sizeof(uint64_t) * 4);
  for(i = 0; i < 5; i ++)
    f_255_19_multiply(g, g);
  f_255_19_multiply(g, z); //  g = g^(2^255 -21)
}
@

Existem outros métodos. Por exemplo, em [BERNSTEIN, 2019] há um
algoritmo que também roda em tempo constante e é um pouco mais rápido,
mas requer operações bem mais complicadas. Mas para o nosso grupo
multiplicativo, vamos optar por usar o método mais simples.

\subsecao{A Curva Elíptica Curve25519}

Dado o corpo finito apresentado na seção anterior, podemos construir
uma curva elíptica definida por $y^2=x^3+486662x^2+x$. Onde os valores
dos pares $(x,y)$ não são números reais, mas elementos do corpo finito
apresentado.

Com ajuda desta curva, podemos definir um grupo matemático formado por
pontos da curva e mais um ponto adicional chamado de ``ponto no
infinito''. A operação de adição no grupo (A+B) é definida como sendo
igual ao um terceiro ponto (C) da curva que é interceptada pela reta
que passa por A e B. O ponto no infinito é definido como o elemento
neutro desta adição. O inverso aditivo de um ponto da curva $(a,b)$ é
igual a $(a, -b)$ (pois a curva é simétrica no eixo $x$). E a soma de
um ponto com ele mesmo é igual ao segundo ponto da curva cruzado pela
reta tangente que passa por ele mesmo.

Embora as operações deste grupo sejam definidas geometricamente, e
possam ser visualizadas geometricamente se definirmos esta curva no
plano cartesiano, na verdade estaremos usando ela não no plano real,
mas no plano do corpo finito de inteiros módulo $2^{255}-19$. Então as
transformações feitas, mesmo seguindo a mesma lógica, não podem ser
visualizadas graficamente.

Tecnicamente, para representar um ponto na curva, precisamos de dois
valores: a coordenada $x$ e a coordenada $y$. Entretanto, a curva que
usaremos é um tipo especial de cuurva chamada de ``Curva de
Montgomery''. Que é qualquer curva na forma $By^2=x^3+Ax^2+x$ tal que
$B(A^2-4)\neq 0$. Neste tipo de curva, podemos obter um desempenho
melhor e evitar ter que armazernar o valor no $y$ de cada ponto ao
realizar todas as operações geométricas em uma projeção que não
diferencia entre $A+B$, $A-B$ e $B-A$ ao fazermos as operações de
grupo.

Usando tal truque, cada ponto pode ser armazenado e gerado como sendo
formado somente por um valor $x$, ignorando a coordenada
$y$. Entretanto, os algoritmos os representam como dois valores: $(x:
z)$. O valor $z$ é sempre 0 para o ponto no infinito e começa valendo
1 para outros valores. De certa forma, ele pode ser visto como uma
representação em fração do nosso ponto, com o valor de $z$ sendo um
denominador que acumulará valores e será ``simplificado'' e removido
somente uma só vez no final como forma de ter que calcular somente uma
vez o inverso multiplicativo (a operação mais cara computacionalmente
no corpo finito).

Usando fórmulas e tal método, podemos calcular o dobro de um ponto na
curva $P+P$ (onde $P=(x:z)$) usando a função abaixo:

@<Funções Auxiliares Locais (network.c)@>+=
void curve25519_double(uint64_t x[4], uint64_t z[4]){ // P = P+P
  uint64_t a[4], b[4], e[4], constant[4];
  constant[0] = constant[1] = constant[2] = 0x0;
  constant[3] = 121666;
  memcpy(a, x, sizeof(uint64_t) * 4);
  f_255_19_add(a, z);
  f_255_19_multiply(a, a);
  memcpy(b, z, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(b);
  f_255_19_add(b, x);
  f_255_19_multiply(b, b);
  memcpy(e, b, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(e);
  f_255_19_add(e, a);
  memcpy(x, a, sizeof(uint64_t) * 4);
  f_255_19_multiply(x, b);
  z[0] = z[1] = z[2] = 0x0; z[3] = 121666;
  f_255_19_multiply(z, e);
  f_255_19_add(z, b);
  f_255_19_multiply(z, e);
}
@

Para calcular o verdadeiro valor da coordenada $x$ do resultado, é
preciso computar $x\cdot z^{-1}$. Mas esta operação final deve ser
adiada o máximo possível para ser feita somente no fim das operações
com os pontos da curva. Portanto, a função acima não a realiza.

Já para calcular a soma de dois pontos $P=(x_1: z_1)$ e $Q=(x_2:
z_2)$, isso é impossível de ser feito sem levar em conta as
coordenadas $y$ dos pontos, exceto em um caso especial: se queremos
calcular $P+Q$, mas sabemos qual é a coordenada $x$ de $P-Q$, então
podemos usar este conhecimento para somar os pontos sem precisar
consultar $y$ (chamamos isso de soma diferencial). Para somarmos dois
pontos desta forma, usamos a função abaixo que recebe como dois
primeiros parâmetros os operandos $P = (x_1: z_1)$ e $Q=(x_2: z_2)$ da
soma (o primeiro operando será sobrescrito com a resposta) e tem como
terceiro parâmetro o ponto correspondente a $P-Q$. A função abaixo só
gera o resultado correto para $P\neq Q$ e quando ambos não são o ponto
no infinito.

@<Funções Auxiliares Locais (network.c)@>+=
void curve25519_add(uint64_t x1[4], uint64_t z1[4],
                    uint64_t x2[4], uint64_t z2[4],
		    uint64_t xb[4], uint64_t zb[4]){ // P = P+Q
  uint64_t a[4], b[4], c[4], d[4], x[4], z[4];
  memcpy(a, x1, sizeof(uint64_t) * 4);
  f_255_19_add(a, z1); // a = x1+z1
  memcpy(b, z1, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(b);
  f_255_19_add(b, x1); // b = x1-z1
  memcpy(c, x2, sizeof(uint64_t) * 4);
  f_255_19_add(c, z2); // c = x2+z2
  memcpy(d, z2, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(d);
  f_255_19_add(d, x2); // d = x2-z2
  f_255_19_multiply(d, a); // d = d*a = (x2-z2)(x1+z1)
  f_255_19_multiply(c, b); // c = c*b = (x2+z2)(x1-z1)
  memcpy(x, d, sizeof(uint64_t) * 4);
  f_255_19_add(x, c);
  f_255_19_multiply(x, x);
  f_255_19_multiply(x, zb); //x = zb*(d*a+c*b)^2
  memcpy(z, c, sizeof(uint64_t) * 4);
  f_255_19_additive_inverse(z);
  f_255_19_add(z, d);
  f_255_19_multiply(z, z);
  f_255_19_multiply(z, xb); //z = xb*(d*a-c*b)^2
  memcpy(x1, x, sizeof(uint64_t) * 4);
  memcpy(z1, z, sizeof(uint64_t) * 4);
}
@

\secao{Referências}

\referencia{Bernstein, D. J., Yang B.-Y. (2019) ``Fast Constant Time
GDC Computation and Modular Inversion''.  IACR Transactions on
Cryptographic Hardware and Embedded Systems.}



\fim