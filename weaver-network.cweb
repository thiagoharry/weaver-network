\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Módulo de Rede Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents an implementation, using literate
programming, of the network code required for secure synchronization
between different instances of a game or interactive software built on
the Weaver game engine. It covers both the message exchange mechanisms
and the cryptographic components responsible for ensuring
confidentiality, integrity, and mutual authentication among the
participating programs.}

\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo apresenta uma implementação, utilizando
programação literária, do código de rede necessário para a
sincronização segura entre diferentes instâncias de um jogo ou
software interativo baseado no motor de jogos Weaver. São abordados
tanto os mecanismos de troca de mensagens quanto os componentes
criptográficos responsáveis por garantir confidencialidade,
integridade e autenticação mútua entre os programas participantes.}

\secao{1. Introdução}

\subsecao{1.1. Funções a Serem Exportadas}

O módulo de rede do motor de jogos Weaver atua definindo e exportando
uma série de funções que podem ser usadas externamente. Listaremos
aqui as funções e suas assinaturas.

Primeiro a função de inicialização e finalização. A inicialização deve
ser a primeira função a ser chamada, antes de qualquer outra função a
ser mostrada abaixo. Após invocar a finalização, não se deve chamar
novamente nenhuma outra função definida aqui (exceto a função de
inicialização caso queira-se voltar a inicializar o módulo). A função
de inicialização também deve receber pares de função que fazem
alocação e desalocação de memória. Um par para alocações temporárias e
outro para alocações permanentes. Adicionar este tipo de suporte a
gerenciadores de memória personalizados é algo que todo módulo Weaver
faz.

@<Declaração de Função (network.h)@>=
void _Winit_network(void *(*permanent_alloc)(size_t),
                    void (*permanent_free)(void *),
                    void *(*temporary_alloc)(size_t),
                    void (*temporary_free)(void *));
void _Wfinish_network(void);
@

Para gerar uma nova conexão (mas ainda não ativá-la), usamos:

@<Declaração de Função (network.h)@>+=
struct connection *_Wcreate_connection(void);
@

\subsecao{1.2. Programação Literária}

Nosso código será escrito usando técnica de programação literária
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{network.h}.

Podemos apresentar aqui a estrutura do arquivo \monoespaco{network.h}:

@(src/network.h@>=
#ifndef __WEAVER_NETWORK
#define __WEAVER_NETWORK
#ifdef __cplusplus
extern "C" {
#endif
#include <stdlib.h> // Biblioteca padrão
//@<Inclui Cabeçalhos Gerais (network.h)@>
//@<Macros Gerais (network.h)@>
//@<Estrutura de Dados (network.h)@>
@<Declaração de Função (network.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (network.h)'', o mesmo nome apresentado no trecho de
código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{network.c}
associado a este cabeçaho, o código será este:

@(src/network.c@>=
#include "network.h"
#if defined(__EMSCRIPTEN__)
#include <emscripten.h>
#endif
#include <stdbool.h> // Suporte a tipos booleanos
#include <string.h>  // Usaremos 'memset'
#include <unistd.h>  // Usaremos 'close'
@<Cabeçalhos Locais (network.c)@>
//@<Macros Locais (network.c)@>
//@<Estrutura de Dados Locais (network.c)@>
@<Variáveis Locais (network.c)@>
@<Funções Auxiliares Locais (network.c)@>
@<Definição de Funções da API (network.c)@>
@


Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. Inicialização do Módulo de Rede}

A primeira parte do código que vamos introduzir são os cabeçalhos de
uso da rede. No Windows, a biblioteca usada é o ``winsock2''. Essa
biblioteca também deve ser ligada externamente ao programa, mas isso
pode ser feito com uma diretiva ``pragma'' para o compilador:

@<Cabeçalhos Locais (network.c)@>=
#if defined(_WIN32)
#include <winsock2.h>
#pragma comment(lib,"wsock32.lib")
#endif
@

Em sistemas baseados em Unix, só precisamos incluir os cabeçalhos
adequados. A capacidade de se conectar já faz parte das bibliotecas
padrão e não requer a ligação com bibliotecas externas:

@<Cabeçalhos Locais (network.c)@>+=
#if defined(__unix__)
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#endif
@

Se estivermos executando WebAssembly em um navegador de Internet, a
conexão de rede deve sr feita usando recursos do próprio navegador, e
isso não requer cabeçalhos especiais.

Na maioria dos ambientes, não é necessário realizar nenhum tipo de
inicialização especial antes de usar as funções para estabelecer
conexões de rede. Mas há exceções (o Windows, por exemplo), e por
causa disso é importante existir uma função que cuida da inicialização
do módulo de rede. Tal função faz a inicialização nos sistemas em que
isso é necessário. Nos demais sistemas, a inicialização ainda é
importante, mas apenas para armazenarmos as nossas funções de alocação
e desalocação.

@<Cabeçalhos Locais (network.c)@>+=
#include <stdlib.h> // Requer: 'malloc', 'free'
@

@<Variáveis Locais (network.c)@>=
// Por padrão as funções de alocação serão as da biblioteca padrão.
// Mas a inicialização pode modificar o valor padrão delas:
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@

@<Definição de Funções da API (network.c)@>=
// A função de inicialização:
void _Winit_network(void *(*p_alloc)(size_t), void (*p_free)(void *),
                    void *(*t_alloc)(size_t), void (*t_free)(void *)){
  permanent_alloc = p_alloc;
  permanent_free = p_free;
  temporary_alloc = t_alloc;
  temporary_free = t_free;  
#if defined(_WIN32) // Windows:
  WSADATA WsaData;
  WSAStartup(MAKEWORD(2,2), &WsaData);
#endif
  //@<Weaver Network: Inicialização@>
  return;
}
@

Sistemas que requerem uma inicialização adicional para usar a rede
podem precisar também de uma finalização, que é invocada abaixo:

@<Definição de Funções da API (network.c)@>+=
void _Wfinish_network(void){
#if defined(_WIN32) // Windows:
  WSACleanup();
#endif
  return;
}
@

\secao{3. Primitivas de Rede}

\subsecao{3.1. Identificando um Endereço}

Antes de iniciarmos qualquer tipo de conexão, devemos ser capazes de
saber a qual endereço devemos nos conectar. Endereços podem ser IPs de
outras máquinas em IPv4 ou IPv6. Podem ser também um nome de domínio.

As regras que adotaremos para identificar o tipo de endereço são
baseadas no RFC 3986:

\alinhaverbatim
<endereço>         -> <host>
<host>             -> <Endereço IPv6>
                      <Endereço IPv4> |
	              <Nome de Registro>
<Endereço IPv4>    -> <Octeto Decimal> "." <Octeto Decimal> "." <Octeto Decimal>
                      "." <Octeto Decimal>
<Endereço IPv6>    -> Regras elaboradas a estabelecer. Mas sempre contém ":".
<Octeto Decimal>   -> Número entre 0 e 255 (inclusive). Sem zeros à esquerda.
<Nome de Registro> -> Qualquer quantidade de letras, dígitos, caracteres e
                      diversos símbolos, mas sem ":", "[" e "]"
\alinhanormal

Precisamos então de uma função que recebe um inteiro e retorna um
inteiro representando um tipo de endereço. O retorno será -1 se o
endereço não for válido, 1 se for um IPv4, 2 se for IPv6 e 3 se for um
nome de domínio.

A função funcionará armazenando uma variável
\monoespaco{may\_be\_ipv4} que será inicializada como verdadeira, mas
se tornará falsa assim que encontrarmos algo que indica que o que
temos não pode ser um IPv4. Isso ocorre porque existe ambigüidade nas
regras de como definir um nome de domínio e um IPv4, mas enquanto algo
puder ser interpretado como IPv4, esta deve ser a interpretação
preferencial.

Para identificarmos que tipo de endereço temos, iremos iterar sobre
cada caractere do endereço. Tão logo encontramos um caractere de dois
pontos (``:''), o endereço sópode ser IPv6. Interrompemos toda a
computação e retornamos. Assim que encontramos uma letra minúscula ou
maiúscula acima de ``f'' ou ``F'', podemos assumir com certeza
absoluta que temos um nome de registro (domínio).

Se chegarmos até o fim do nosso loop e identificarmos que o endereço
pode ser um IPv4, ele será um IPv4. Caso contrário, ele será um nome
de registro de domínio (um IPv6 sempre tem um ``:'', então retornamos
de nossa função antes do fim do loop se encontrarmos tal caractere).

Enquanto nosso endereço pode ser um IPv4, contamos os caracteres que
recebemos até o próximo ponto e os concatenamos em um buffer. Se
lermos mais de 3 caracteres, certamente não será um IPv4. Se o
caractere não for numérico, não será IPv4. Se lermos 2 ou 3 caracteres
que tenham um zero à esquerda, também não será IPv4. Se os caracteres
não puderem ser convertidos para um número entre 0 e 255, também não
será IPv4.

Eis agora o nosso código:


@<Funções Auxiliares Locais (network.c)@>=
#define ADDRESS_TYPE_INVALID -1
#define ADDRESS_TYPE_IPV4     1
#define ADDRESS_TYPE_IPV6     2
#define ADDRESS_TYPE_DOMAIN   3
int detect_address_type(char *address){
  bool may_be_ipv4 = true;
  char buffer[4], *c;
  int number_of_chars_before_point = 0;
  if(address[0] == '\0')
    return ADDRESS_TYPE_INVALID;
  for(c = address; *c != '\0'; c ++){
    if(*c == ':')
      return ADDRESS_TYPE_IPV6;
    if((*c > 'f' && *c <= 'z') || (*c > 'F' && *c <= 'Z'))
      return ADDRESS_TYPE_DOMAIN;
    if(may_be_ipv4){
      if(*c == '.'){
        int num;
        if(number_of_chars_before_point < 1 ||
	   number_of_chars_before_point > 3){
          may_be_ipv4 = false;
          continue;
        }
	if(number_of_chars_before_point > 1 && buffer[0] == '0'){
          may_be_ipv4 = false;
          continue;
        }
	buffer[number_of_chars_before_point] = '\0';
	num = atoi(buffer);
	if(num > 255){
          may_be_ipv4 = false;
          continue;
        }
	number_of_chars_before_point = 0;
	continue;
      }
      if(*c < '0' || *c > '9'){
        may_be_ipv4 = false;
	continue;
      }
      buffer[number_of_chars_before_point] = *c;
      number_of_chars_before_point ++;
      if(number_of_chars_before_point > 3){
        may_be_ipv4 = false;
	continue;
      }
    }
  }
  if(may_be_ipv4)
    return ADDRESS_TYPE_IPV4;
  else
    return ADDRESS_TYPE_DOMAIN;
}
@

\subsecao{Conectando a um Endereço}

Quando nos conectamos a outra máquina, precisamos saber o seu
endereço, a sua porta e se a conexão deve ser feita via TCP ou
UDP. Para isso iremos definir uma função que recebe como argumento
estas três informações, cria um socket e se conecta a ele abrindo uma
conexão com a máquina indicada.

A função irá receber os seguintes valores como entrada:

1) ``address'': Um endereço. Que é uma string com um endereço IPv4,
IPv6 ou um nome de domínio.

2) ``port'': Uma string contendo um número de porta escrito com
algarismos decimais. Ou, alternativamente, o nome de um protocolo
reconhecido pelo Sistema Operacional em que estamos executando caso
queiramos que o Sistema Operacional indique a porta correta.

3) Um valor que pode ser SOCK_STREAM (TCP) ou SOCK_DGRAM (UDP).

O valor de retorno será um inteiro que é o idendificador de um socket
que foi aberto e está conectado ao endereço indicado. Ou -1 caso não
tenha sido possível se conectar.

Para implementarmos isso, iremos confiar na função ``getaddrinfo'' que
fará a maior parte do trabalho de interpretar o endereço indicado e
gerar estruturas que podem então ser usadas pela função de sistema
``connect'':


@<Funções Auxiliares Locais (network.c)@>=
int connect_socket(char *address, char *port, int type){
  struct addrinfo hints;
  int s, sfd;
  struct addrinfo *result, *rp;
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;    /* IPv4 ou IPv6 */
  hints.ai_socktype = type;
  s = getaddrinfo(address, port, &hints, &result);
  if(s != 0)
    return -1;
  for (rp = result; rp != NULL; rp = rp->ai_next) {
    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if(sfd == -1)
      continue;
    if(connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
      break; /* Sucesso */
    close(sfd);
  }
  freeaddrinfo(result); /* Desalocando*/
  if(rp == NULL)
    return -1;
  return sfd;
}
@




\fim